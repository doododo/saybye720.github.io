<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>大脸的博客</title>
   <link href="http://blog.11010.net/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://blog.11010.net" rel="alternate" type="text/html" />
   <updated>2014-07-16T18:09:23+08:00</updated>
   <id>http://blog.11010.net</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>VPS环境搭建详解 (Virtualenv+Gunicorn+Supervisor+Nginx)</title>
     <link href="http://blog.11010.net/vps-config-python-vitrualenv-flask-gunicorn-supervisor-nginx"/>
     <updated>2014-01-25T00:00:00+08:00</updated>
     <id>http://beiyuu.com/vps-config-python-vitrualenv-flask-gunicorn-supervisor-nginx</id>
     <content type="html">&lt;p&gt;新用户注册购买&lt;a href=&quot;https://www.digitalocean.com/?refcode=f95f7297ed94&quot; title=&quot;DigitalOcean&quot;&gt;DigitalOcean&lt;/a&gt;的VPS，使用优惠码&lt;code&gt;2014SSD&lt;/code&gt;（或请尝试&lt;code&gt;10TOSHIP&lt;/code&gt;）有$10赠送，可用两个月。DO采取丧心病狂的低价竞争策略，每月$5即可享用全功能的SSD硬盘VPS，具体去看看&lt;a href=&quot;https://www.digitalocean.com/?refcode=f95f7297ed94&quot; title=&quot;DigitalOcean&quot;&gt;这里&lt;/a&gt;吧。&lt;/p&gt;

&lt;p&gt;注册，选择套餐、机房、系统(我选默认Ubuntu 12)，付款成功，可以开始配置了。&lt;/p&gt;

&lt;p&gt;我们目标实现一个支持多个独立域名网站的线上Python环境，这会用到&lt;a href=&quot;http://www.virtualenv.org/en/latest/&quot; title=&quot;Virtualenv&quot;&gt;Virtualenv&lt;/a&gt;， &lt;a href=&quot;http://flask.pocoo.org/docs/&quot; title=&quot;Flask&quot;&gt;Flask&lt;/a&gt;， &lt;a href=&quot;http://gunicorn.org/&quot; title=&quot;Gunicorn&quot;&gt;Gunicorn&lt;/a&gt;， &lt;a href=&quot;http://supervisord.org/&quot; title=&quot;Supervisor&quot;&gt;Supervisor&lt;/a&gt;， &lt;a href=&quot;http://nginx.com/&quot; title=&quot;Nginx&quot;&gt;Nginx&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;配置用户环境&lt;/h2&gt;

&lt;p&gt;因为要跑多个站，所以最好将他们完全隔离，每个站对应一个用户，于是我们有了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; User        Site

 bob         dylan     ##bob用户有一个dylan的站
michael     jackson    ##michael用户有一个jackson的站
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注册成功后，会收到DO发来的&lt;code&gt;root&lt;/code&gt;账户的密码邮件，&lt;code&gt;ssh root@你的IP地址&lt;/code&gt;登录上去开始添加用户。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##推荐安装zsh作为默认shell
sudo apt-get update
sudo apt-get install zsh

##安装oh-my-zsh插件
cd ~/.
##自动安装脚本
wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh

##添加用户bob
##参数-d：指定用户目录
##参数-m：如果目录不存在则创建
##参数-s：只用用户使用的 shell
useradd bob -d /home/bob -m -s /bin/zsh

#添加用户michael
useradd michael -d /home/michael -m -s /bin/zsh

##以上参数也可以修改passwd文件来调整
sudo vim /etc/passwd

##sudo和用户组管理在
visudo
sudo vim /etc/sudoers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新增用户之后，需要解锁：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##为新增用户设置一个初始密码即可解锁
passwd bob
passwd michael
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用ssh-keygen建立信任关系可以方便登录管理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##本地机器
##会在~/.ssh目录下生成秘钥文件id_rsa、id_rsa.pub
ssh-keygen -t [rsa|dsa]

##复制公钥文件id_rsa.pub
scp ~/.ssh/id_rsa.pub bob@digitalocean:~/.ssh

##VPS上，添加本地机器的信任关系
cd ~/.ssh
cat id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys

##OK，从本地机器登录到VPS的bob用户就不需要密码了
##同理，也可以添加到michael用户的.ssh目录下
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多资料可以阅读：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.chinaunix.net/old_jh/4/438660.html&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;Linux的用户和用户组管理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sofish.de/1685&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;把 Mac 上的 bash 换成 zsh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://leeiio.me/bash-to-zsh-for-mac/&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;zsh – 给你的Mac不同体验的Terminal&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/kongqz/article/details/6338690&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;ssh-keygen的使用方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/03/server_setup.html&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;Linux服务器的初步配置流程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/03/server_setup.html&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;Linux服务器的初步配置流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;为每个APP创建Virtualenv&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.virtualenv.org/en/latest/&quot; title=&quot;Virtualenv&quot;&gt;Virtualenv&lt;/a&gt;可以为每个Python应用创建独立的开发环境，使他们互不影响，Virtualenv能够做到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在没有权限的情况下安装新套件&lt;/li&gt;
  &lt;li&gt;不同应用可以使用不同的套件版本&lt;/li&gt;
  &lt;li&gt;套件升级不影响其他应用&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;安装Virtualenv&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##先安装Python的包管理pip
sudo apt-get install pip

##用pip安装virtualenv
sudo pip install virtualenv

##建议用bob用户登录操作
##bob用户创建dylan的virtualenv
cd /home/bob
virtualenv dylan

##激活virtualenv
cd /home/bob/dylan
source ./bin/activate

##取消激活只需
deactivate

##michael用户如法炮制即可
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装Flask&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://flask.pocoo.org/docs/&quot; title=&quot;Flask&quot;&gt;Flask&lt;/a&gt;是Python流行的一个web框架，但是Flask比Django轻量了许多，使用更加直观，这里并不展开讲Flask的细节，当做一个Hello Wordld来用就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##安装Flask
##依然在virtualenv activate的环境下
pip install Flask

##根目录下
vim runserver.py

##写入Flask的Hello World
from flask import Flask
app = Flask(__name__)

@app.route(&#39;/&#39;)
def hello_world():
    return &#39;Hello World!&#39;

    if __name__ == &#39;__main__&#39;:
        app.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写入之后，如果在本地机器上可以运行&lt;code&gt;python runserver.py&lt;/code&gt;，然后打开&lt;code&gt;127.0.0.1:5000&lt;/code&gt;看到Hello World!了，但在VPS，这样不行，等待后面配置吧。&lt;/p&gt;

&lt;h2&gt;安装Gunicorn&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://gunicorn.org/&quot; title=&quot;Gunicorn&quot;&gt;Gunicorn&lt;/a&gt;是用于部署WSGI应用的，任何支持WSGI的都可以，虽说直接&lt;code&gt;python runserver.py&lt;/code&gt;这样网站也能跑起来，但那是方便开发而已，在线上环境，还是需要更高效的组件来做。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##安装Gunicorn
##依然在Virtualenv环境下
pip install gunicorn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gunicorn的配置是必须的，因为我们要上两个独立的站，所以不能都用默认的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##在bob的dylan项目下
cd /home/bob/dylan
vim gunicorn.conf

##文件内写入以下内容
##指定workers的数目，使用多少个进程来处理请求
##绑定本地端口
workers = 3
bind = &#39;127.0.0.1:8000&#39;

##在michael的jackson项目下
cd /home/michael/jackson
vim gunicorn.conf

##写入文件内容
##与dylan的端口要不一样
workers = 3
bind = &#39;127.0.0.1:8100&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终的目录结构应该是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/
└── bob  //用户目录
│   ├── logs
│   └── dylan  //项目目录
│       ├── bin
│       │   ├── activate
│       │   ├── easy_install
│       │   ├── gunicorn
│       │   ├── pip
│       │   └── python
│       ├── include
│       │   └── python2.7 -&amp;gt; /usr/include/python2.7
│       ├── lib
│       │   └── python2.7
        ├── local
│       │   ├── bin -&amp;gt; /home/shenye/shenyefuli/bin
│       │   ├── include -&amp;gt; /home/shenye/shenyefuli/include
│       │   └── lib -&amp;gt; /home/shenye/shenyefuli/lib
│       │
│       │ //以上目录是Virtualenv生成的
│       ├── gunicorn_conf.py  //Gunicorn的配置文件
│       └── runserver.py  //hello_world程序
│
│
└── michael  //用户目录
    ├── logs
    └── jackson //项目目录
        ├── bin
        │   ├── activate
        │   ├── easy_install
        │   ├── gunicorn
        │   ├── pip
        │   └── python
        ├── include
        │   └── python2.7 -&amp;gt; /usr/include/python2.7
        ├── lib
        │   └── python2.7
        ├── local  //以上这些文件都是Virtualenv需要的
        │   ├── bin -&amp;gt; /home/shenye/shenyefuli/bin
        │   ├── include -&amp;gt; /home/shenye/shenyefuli/include
        │   └── lib -&amp;gt; /home/shenye/shenyefuli/lib
        │
        │ //以上目录是Virtualenv生成的
        ├── gunicorn_conf.py  //Gunicorn的配置文件
        └── runserver.py  //hello_world程序
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装Supervisor&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://supervisord.org/&quot; title=&quot;Supervisor&quot;&gt;Supervisor&lt;/a&gt;可以同时启动多个应用，最重要的是，当某个应用Crash的时候，他可以自动重启该应用，保证可用性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##安装Supervisor
##sudo安装
sudo apt-get install supervisor

##启动服务
sudo service supervisor start
##终止服务
sudo service supervisor stop
##也可以直接kill pid
ps -A | grep supervisor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改了程序代码，或者修改了配置，需要手动重启supervisor服务，尤其是摸不着头脑的错误的时候，重启最能解决问题！&lt;/p&gt;

&lt;p&gt;安装好之后，开始配置各应用的supervisor服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##supervisor的配置文件位置在：
/etc/supervisor/supervisor.conf

##为了代码好看一些，我们分别放置各项目的配置文件
##新建bob的dylan项目配置文件
touch /etc/supervisor/conf.d/dylan.conf

##文件内容
[program:dylan]
##注意项目目录和gunicorn的配置文件地址
command=/home/bob/dylan/bin/gunicorn runserver:app -c /home/bob/dylan/gunicorn.conf
directory=/home/bob/dylan
user=bob
autostart=true
autorestart=true
##log文件的位置
stdout_logfile=/home/bob/logs/gunicorn_supervisor.log


##新建michael的jackson项目配置文件
touch /etc/supervisor/conf.d/jackson.conf

##文件内容
[program:jackson]
command=/home/michael/jackson/bin/gunicorn runserver:app -c /home/michael/jackson/gunicorn.conf
directory=/home/michael/jackson
user=michael
autostart=true
autorestart=true
stdout_logfile=/home/michael/logs/gunicorn_supervisor.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写好配置之后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##重新读取配置
sudo supervisorctl reread

##启动服务
sudo supervisorctl start dylan
sudo supervisorctl start jackson

##停止服务
sudo supervisorctl stop dylan
sudo supervisorctl stop jackson

##有问题就重启supervisor的总服务
sudo service supervisor stop
sudo service supervisor start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装Nginx&lt;/h2&gt;

&lt;p&gt;有了&lt;a href=&quot;http://gunicorn.org/&quot; title=&quot;Gunicorn&quot;&gt;Gunicorn&lt;/a&gt;、&lt;a href=&quot;http://supervisord.org/&quot; title=&quot;Supervisor&quot;&gt;Supervisor&lt;/a&gt;，本地的环境的算是搭好了，但是我们需要让VPS上的网站从外网可以访问，这时候需要Nginx。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nginx.com/&quot; title=&quot;Nginx&quot;&gt;Nginx&lt;/a&gt;是轻量级、性能强、占用资源少，能很好的处理高并发的反向代理软件，是我们的不二选择：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##安装Nginxx
sudo apt-get install nginx

##启动服务
sudo service nginx start

##查看VPS的IP地址
ifconfig eth0 | grep inet | awk &#39;{ print $2  }&#39;

##重启和暂停服务
sudo service nginx restart
sudo service nginx stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nginx的配置文件和Supervisor类似，不同的程序可以分别配置，然后被总配置文件include：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##Nginx的配置文件地址
/etc/nginx/nginx.conf

##新建bob的dylan项目配置文件
##在sites-available目录下
touch /etc/nginx/sites-available/dylan.com

##文件内容
server {
        listen   80;             //端口
        server_name dylan.com;   //访问域名

        root /home/bob/dylan/;
        access_log /home/bob/logs/access.log;
        error_log /home/bob/logs/access.log;

        location / {
                proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
                proxy_redirect off;
                if (!-f $request_filename) {
                        proxy_pass http://127.0.0.1:8000;  //这里是dylan的gunicorn端口
                        break;
                }
        }
}


##michael的jackson项目
touch /etc/nginx/sites-available/jackson.com

##文件内容
server {
        listen   80;               //端口
        server_name jackson.com;   //访问域名

        root /home/michael/jackson/;
        access_log /home/michael/logs/access.log;
        error_log /home/michael/logs/access.log;

        location / {
                proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
                proxy_redirect off;
                if (!-f $request_filename) {
                        proxy_pass http://127.0.0.1:8100;  //这里是jackson的gunicorn端口
                        break;
                }
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完成之后，&#39;sudo service nginx restart&#39;重启一下服务，再配置一下本地的Hosts，打开浏览器应该就能看到了。&lt;/p&gt;

&lt;h2&gt;完成&lt;/h2&gt;

&lt;p&gt;至此，一个完整的环境搭建就完成了，推荐试用&lt;a href=&quot;https://www.digitalocean.com/?refcode=f95f7297ed94&quot; title=&quot;DigitalOcean&quot;&gt;DigitalOcean&lt;/a&gt;的VPS看看，&lt;code&gt;2014SSD&lt;/code&gt;（或请尝试&lt;code&gt;10TOSHIP&lt;/code&gt;）的优惠码也可以试试看看有没有过期哦~&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>CSS3动画详解</title>
     <link href="http://blog.11010.net/css3-animation"/>
     <updated>2013-08-24T00:00:00+08:00</updated>
     <id>http://beiyuu.com/css3-animation</id>
     <content type="html">&lt;h2&gt;CSS3动画&lt;/h2&gt;

&lt;p&gt;有人认为CSS动画是做了js的事情，较真起来也算，只是已经抢占许多年了，早些年要实现鼠标滑过链接变色的基本效果，需要动用Java Applet，后来只需给HTML元素加事件&lt;code&gt;onclick=changecolor()&lt;/code&gt;，再之后正如你所知，只要写&lt;code&gt;:hover&lt;/code&gt;、&lt;code&gt;:focus&lt;/code&gt;这样的伪类即可，同样的，现在有了CSS3动画。&lt;/p&gt;

&lt;h4&gt;CSS3动画的优势：&lt;/h4&gt;

&lt;ul&gt;
    &lt;li&gt;写起来非常方便，不会js也没问题&lt;/li&gt;
    &lt;li&gt;有些动画js也不能很好的胜任，比如让一个元素在二维、三维空间旋转&lt;/li&gt;
    &lt;li&gt;运行效果流畅，让浏览器去优化性能&lt;/li&gt;
    &lt;li&gt;浏览器从底层优化动画序列，例如当tab不可见的时候，降低更新的频率提高整体性能&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;劣势：&lt;/h4&gt;

&lt;ul&gt;
    &lt;li&gt;CSS3动画应用的范围还是有限&lt;/li&gt;
    &lt;li&gt;兼容性：对于增强体验的Feature来说，可以无视&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;可以做动画效果的属性&lt;/h3&gt;

&lt;p&gt;理论上来说，任何单独的CSS属性都可以做动画的效果，比如：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;width&lt;/code&gt;：10px 到 100px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;padding&lt;/code&gt;：0px 到 20px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;color&lt;/code&gt;：#F00 到 #00F&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;top&lt;/code&gt;：0px 到 10px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;border-radius&lt;/code&gt;：3px 到 8px&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;transform&lt;/code&gt;：rotate(0deg) 到 ratate(45deg)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;你也可以给&lt;code&gt;red&lt;/code&gt;、&lt;code&gt;blue&lt;/code&gt;这样的赋值的颜色属性加transition或animation，它会被自动转化为对应的RGB值。&lt;/p&gt;

&lt;h3&gt;不可以做动画效果的属性&lt;/h3&gt;

&lt;p&gt;看下面这些例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p {
    display: none;
    transition: all 3s ease;
}

#container:hover p {
    display: block;
}

/**********************/

#container p {
    height: 0px;
    transition: all 3s ease;
}

#container:hover p {
    height: auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性从无到有或到不确定值，动画效果不会生效，因为浏览器不知道如何去做，对于元素从无到有，你可以选择&lt;code&gt;opacity&lt;/code&gt;属性来处理。&lt;/p&gt;

&lt;h2&gt;CSS3 Transition&lt;/h2&gt;

&lt;p&gt;Transition是被用到最多的也是最简单的CSS3动画类型。如果要做一个10px宽的蓝色元素在3s后变成一个100px宽的红色元素的效果，Transition可以平滑实现，你只需要声明起始和终止这两个状态。&lt;/p&gt;

&lt;p&gt;Transition的触发也很简单，可以用&lt;code&gt;:hover&lt;/code&gt;、&lt;code&gt;:focus&lt;/code&gt;这样的伪类来触发，也可以通过改变元素的样式来触发。&lt;/p&gt;

&lt;h3&gt;transition的属性&lt;/h3&gt;

&lt;h4&gt;transition-property&lt;/h4&gt;

&lt;p&gt;transition-property用来声明transition会被应用到的属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p.one {
    transition-property: color;
}

#container p.two {
    transition-property: width;
}

#container p.three {
    transition-property: color, width;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想应用到所有属性，那可以简单写作&lt;code&gt;all&lt;/code&gt;，也可以通过&lt;code&gt;none&lt;/code&gt;来关闭transition。&lt;/p&gt;

&lt;h4&gt;transition-duration&lt;/h4&gt;

&lt;p&gt;transition-duration用来声明动画持续的时长，可以是s也可以是ms&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p.one {
    transition-duration: 3s;
}

#container p.two {
    transition-duration: 3000ms;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;transition-timing-function&lt;/h4&gt;

&lt;p&gt;transition-timing-function声明了动画的缓动类型，有下面几个选项：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;ease&lt;/code&gt;：默认项，动画效果慢慢开始然后加速，到中点后再减速最后缓慢到达终点&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;ease-in-out&lt;/code&gt;：与ease类似，加减速更柔和一些&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;ease-in&lt;/code&gt;：开始比较慢，但是加速和停止曲线比较陡峭&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;ease-out&lt;/code&gt;：开始较快，然后缓慢停止&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;linear&lt;/code&gt;：线性平均速率，通常在color和opacity属性的变化上&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最后，还有&lt;code&gt;cubic-bezier&lt;/code&gt;函数，可以自己创造更多更优美的缓动类型。&lt;/p&gt;

&lt;h4&gt;transition-delay&lt;/h4&gt;

&lt;p&gt;transition-delay声明了动画延迟开始的时间，很容易理解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p.one {
    transition-delay: 0.5s;
}

#container p.two {
    transition-delay: 500ms;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;transition简写&lt;/h3&gt;

&lt;p&gt;上面介绍了transition的属性，他们也可以合并成一项，省去了许多拼写，当然也别忘记浏览器前缀：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#container p {
    transition-property: all;
    transition-duration: 3s;
    transition-timing-function: ease-in-out;
    transition-delay: 0.5s;
}


#element {
    /* starting state styles */
    color: #F00;
    -webkit-transition: all 3s ease-in-out 0.5s;
    transition: all 3s ease-in-out 0.5s;
}

#element:hover {
    /* ending state styles */
    color: #00F;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;transition的高级用法&lt;/h3&gt;

&lt;h4&gt;不同的transition效果&lt;/h4&gt;

&lt;p&gt;看这样的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p#animate {
    color: #ff6;
    transition: all 3s ease-in-out 0.5s;
}

p#animate:hover {
    color: #0f0;
    transform: scale(4);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，当鼠标hover，元素在0.5s之后在3s内放大四倍，鼠标移开，需要同样的时间回到原来的状态。如果想要不同的效果，可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p#animate {
    color: #ff6;
    transition: all 0.5s ease-in-out;
}

p#animate:hover {
    color: #0f0;
    transform: scale(4);
    transition: all 3s ease-in-out 0.5s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;多个transition&lt;/h4&gt;

&lt;p&gt;需要给多个transition指定不同的效果时，&lt;code&gt;all&lt;/code&gt;属性解决不了，可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p#animate {
    width: 10em;
    background-color: #F00;
    border-radius: 5px;
    transition-property: width, border-radius, background-color;
    transition-duration: 1s, 2s;
    transition-timing-function:  ease, ease-out, linear;
}

p#animate:hover {
    width: 20em;
    background-color: #00F;
    border-radius: 50%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意其中的&lt;code&gt;transition-duration&lt;/code&gt;只写了两个，那么第三个&lt;code&gt;transition-property&lt;/code&gt;属性&lt;code&gt;background-color&lt;/code&gt;就用循环到第一个，也就是说他的&lt;code&gt;transition-duration&lt;/code&gt;值是&lt;code&gt;1s&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;transition示例&lt;/h3&gt;

&lt;div id=&quot;transition1&quot;&gt;
#transition1 {&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;width:350px;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;background-color:#1abc9c;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transition-propety:width,background-color;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transition-duration:.5s, 1s;&lt;br&gt;
}&lt;br&gt;
#transition1:hover {&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;width:450px;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;background-color:#8e44ad;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transition-duration:.5s, 3s;&lt;br&gt;
}&lt;br&gt;
&lt;/div&gt;


&lt;h2&gt;CSS3 Animation&lt;/h2&gt;

&lt;h3&gt;Animation和Transition的不同&lt;/h3&gt;

&lt;ul&gt;
    &lt;li&gt;和transition一样都可以定义开始和结束状态，但是animation还可以指定更确定的中间状态&lt;/li&gt;
    &lt;li&gt;animation可以像transition一样被触发，也可以自动运行&lt;/li&gt;
    &lt;li&gt;animation可以无限循环的运行下去，也可以指定运行的次数&lt;/li&gt;
    &lt;li&gt;animation可以在顺序运行也可以反向运行&lt;/li&gt;
    &lt;li&gt;animatino写起来稍麻烦些，但是依然比js简单许多&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;定义keyframes&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@keyframes colorchange {
    0%   { background-color: #00F; /* from: blue */ }
    25%  { background-color: #F00; /* red        */ }
    50%  { background-color: #0F0; /* green      */ }
    75%  { background-color: #F0F; /* purple     */ }
    100% { background-color: #00F; /* to: blue   */ }
}

@-webkit-keyframes colorchange {
    0%   { background-color: #00F; /* from: blue */ }
    25%  { background-color: #F00; /* red        */ }
    50%  { background-color: #0F0; /* green      */ }
    75%  { background-color: #F0F; /* purple     */ }
    100% { background-color: #00F; /* to: blue   */ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，只是定义了&lt;code&gt;background-color&lt;/code&gt;这一个属性，如有需要，可以换做其他。对于&lt;code&gt;0%&lt;/code&gt;这个也可以用&lt;code&gt;from&lt;/code&gt;关键字来替代，同样的可以用&lt;code&gt;to&lt;/code&gt;来代替&lt;code&gt;100%&lt;/code&gt;，过渡状态，你可以定义任何百分比，类似&lt;code&gt;12.5%&lt;/code&gt;这样的也可以，不过就不用给自己找麻烦了吧。浏览器的&lt;code&gt;prefix&lt;/code&gt;也不能少。&lt;/p&gt;

&lt;h3&gt;应用到元素&lt;/h3&gt;

&lt;p&gt;将&lt;code&gt;animation&lt;/code&gt;应用到元素的属性写法，和&lt;code&gt;transition&lt;/code&gt;差不太多，顺序都一致，就不在一个个参数重复说明，直接看代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#myelement {
    animation-name: colorchange; /**这里引用了前面定义的动画**/
    animation-duration: 5s;
    animation-timing-function: linear;
    animation-delay: 1s;
    animation-iteration-count: infinite;
    animation-direction: alternate;
}

/****简写****/
#myelement {
    -webkit-animation: colorchange 5s linear 1s infinite alternate;
    animation: colorchange 5s linear 1s infinite alternate;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;animation-iteration-count&lt;/code&gt;用来指定动画循环的次数，无限循环用&lt;code&gt;infinite&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;animation-direction有四个值：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;normal&lt;/code&gt;：默认，从0%执行到100%&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;reverse&lt;/code&gt;：动画从100%执行到0%&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;alternate&lt;/code&gt;：动画在0%到100%之间往复执行&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;alternate-reverse&lt;/code&gt;与&lt;code&gt;alternate&lt;/code&gt;一致，不过是从100%开始&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Animation示例&lt;/h3&gt;

&lt;div id=&quot;ani1&quot;&gt;Animate color&lt;/div&gt;


&lt;h2&gt;CSS3 Transform&lt;/h2&gt;

&lt;p&gt;有了&lt;code&gt;transition&lt;/code&gt;和&lt;code&gt;animation&lt;/code&gt;之后，就可以做出些漂亮的动画效果，如果再搭配&lt;code&gt;transform&lt;/code&gt;这一CSS3动画利器，就更出彩了。&lt;/p&gt;

&lt;h3&gt;CSS3 2D Transform&lt;/h3&gt;

&lt;p&gt;运用CSS3 2D Transform的技术，可以更自由轻松的来修饰HTML元素。CSS3 2D Transform的基本方法有下面这些：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;translate()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;rotate()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;scale()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;skew()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;matrix()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;Translate&lt;/h4&gt;

&lt;p&gt;使用&lt;code&gt;translate()&lt;/code&gt;方法，可以将HTML元素在x-y轴平面上做位移，且不会影响到其他元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div{
    -webkit-transform: translate(20px,20px);
    -moz-transform: translate(20px,20px);
    -o-transform: translate(20px,20px);
    transform: translate(20px,20px);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;div id=&quot;translate1&quot;&gt;
&lt;div id=&quot;trans-inner1&quot;&gt;Normal Div&lt;/div&gt;
&lt;div id=&quot;trans-inner2&quot;&gt;transform:tranlated(40px, 40px)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Rotate&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;rotate()&lt;/code&gt;方法可以将元素按照时钟方向旋转，参数可以是&lt;code&gt;0deg&lt;/code&gt;到&lt;code&gt;360deg&lt;/code&gt;，也是在x-y轴平面，示例如下：&lt;/p&gt;

&lt;div id=&quot;rotate1&quot;&gt;
&lt;div id=&quot;rota-inner1&quot;&gt;Normal Div&lt;/div&gt;
&lt;div id=&quot;rota-inner2&quot;&gt;transform:rotate(-30deg)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Scale&lt;/h4&gt;

&lt;p&gt;和名字的一样，&lt;code&gt;scale()&lt;/code&gt;方法用来放大一个元素，依然是在x-y轴平面，看示例：&lt;/p&gt;

&lt;div id=&quot;scale1&quot;&gt;
    &lt;div id=&quot;sca-inner1&quot;&gt;Normal Div&lt;/div&gt;
    &lt;div id=&quot;sca-inner2&quot;&gt;transform:scale(1.5,1.3)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Skew&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;skew()&lt;/code&gt;方法可以将元素按照指定参数进行扭曲，你需要指定x、y轴的扭曲角度，看示例：&lt;/p&gt;

&lt;div id=&quot;skew1&quot;&gt;
&lt;div id=&quot;sk-inner1&quot;&gt;Normal Div&lt;/div&gt;
&lt;div id=&quot;sk-inner2&quot;&gt;transform:skew(30deg,0)&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;Matrix&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;matrix()&lt;/code&gt;方法是以上所有2D效果的方法的总和，写法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div{
    transform: matrix(a,b,c,d,tx,ty);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本质上&lt;code&gt;scale&lt;/code&gt;、&lt;code&gt;skew&lt;/code&gt;、&lt;code&gt;rotate&lt;/code&gt;、&lt;code&gt;translate&lt;/code&gt;的效果都是通过&lt;code&gt;matrix&lt;/code&gt;实现的，&lt;code&gt;tx&lt;/code&gt;、&lt;code&gt;ty&lt;/code&gt;表示位移量，关于&lt;code&gt;matrix&lt;/code&gt;方法更详细的介绍可以参考这里：&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/&quot;&gt;理解CSS3 transform中的Matrix(矩阵)&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;CSS3 3D Transform&lt;/h3&gt;

&lt;p&gt;了解了2D Transform之后，3D Transform的概念也不会太难，他给HTML元素在x-y平面加上了z轴，我们一个个来看看：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;translate3d(tx,ty,tz)&lt;/code&gt;：他定义了一个3D的位移方法，增加了z轴的偏移量&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;translateZ(tz)&lt;/code&gt;：这个方法只在Z轴偏移，与&lt;code&gt;translateX()&lt;/code&gt;和&lt;code&gt;translateY()&lt;/code&gt;相似&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;scale3d(sx,sy,sz)&lt;/code&gt;：在原有的&lt;code&gt;scale&lt;/code&gt;方法上增加了z轴的参数&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;scaleZ(sz)&lt;/code&gt;：同理，只放大z轴，与&lt;code&gt;scaleX()&lt;/code&gt;和&lt;code&gt;scaleY()&lt;/code&gt;类似&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;rotate3d(rx,ry,rz)&lt;/code&gt;：将元素以给定参数的某一个轴方向旋转&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;rotateX(angle)，rotateY(angle)&lt;/code&gt;和&lt;code&gt;rotateZ(angle)&lt;/code&gt;：只按照某一个轴旋转，&lt;code&gt;rotate3d(1,0,0,30deg)&lt;/code&gt;相当于&lt;code&gt;rotateX(30deg)&lt;/code&gt;，其他类推。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;来看看例子：&lt;/p&gt;

&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;trans-3&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: translateZ(-200px);
&lt;/div&gt;
&lt;/div&gt;




&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;trans-31&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: translateZ(100px);
&lt;/div&gt;
&lt;/div&gt;




&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;rotate-31&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: rotateX(45deg);
&lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;rotate-32&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: rotateY(45deg);
&lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;transform-con&quot;&gt;
&lt;div id=&quot;rotate-33&quot; class=&quot;inner&quot;&gt;
width:100%;&lt;br&gt;
height:100%;&lt;br&gt;
transform: rotateZ(45deg);
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;任何有3D变换的元素，不论最后只是做了2D的变换，或者什么都没做&lt;code&gt;translate3d(0,0,0)&lt;/code&gt;，都会触发浏览器去计算。不过，以后会更新优化也不一定。&lt;/p&gt;

&lt;h3&gt;Perspective&lt;/h3&gt;

&lt;p&gt;激活元素的3D空间，需要&lt;code&gt;perspective&lt;/code&gt;属性，写法有两种：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform: perspective( 600px );
/**或者**/
perspective: 600px;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种不同写法，当应用元素只有一个时候，并没有区别，当有多个元素的时候，我们看看效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pers-red .item{
  background: red;
  transform: perspective( 400px ) rotateY(45deg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;pers-con&quot; id=&quot;pers-red&quot;&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;/div&gt;


&lt;pre&gt;&lt;code&gt;#pers-blue {
  perspective: 400px;
}

#pers-blue .item{
  background: blue;
  transform: rotateY( 45deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;pers-con&quot; id=&quot;pers-blue&quot;&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;item&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;上面这两种写法，都触发了元素的3D行为，函数型的写法&lt;code&gt;transform:perspective(400px)&lt;/code&gt;适用于单个元素，会对每一个元素做3D视图的变换，而&lt;code&gt;perspective:400px&lt;/code&gt;的写法，需写在父元素上，然后以父元素的视角，对多个子元素进行3D变换，多个子元素共享同一个3D空间，可以自己打开console修改感受一下。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;perspective&lt;/code&gt;的参数值，决定了3D效果的强烈程度，可以想象为距离多远去观察元素。值越大，观察距离就越远，同样的旋转值，看起来效果就弱一些；值越小，距离越近，3D效果就更强烈。&lt;/p&gt;

&lt;h4&gt;perspective-orgin&lt;/h4&gt;

&lt;p&gt;通常，对一个元素进行3D变换的时候，变换点都是元素的中心点，如果你想以其他的位置为变换点，那就可以用这个属性来做调整：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perspective-orgin: 20% 70%;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是默认值的&lt;code&gt;perspective-orign:50% 50%&lt;/code&gt;：&lt;/p&gt;

&lt;div id=&quot;transform1&quot;&gt;
&lt;div class=&quot;inner&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/city&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/food&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/people&quot; alt=&quot;Nature&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;这个是&lt;code&gt;perspective-orgin: 0% 50%;&lt;/code&gt;&lt;/p&gt;

&lt;div id=&quot;transform1&quot; sytle=&quot;-webkit-perspective-origin:0% 50%;perspective-origin:0% 50%&quot;&gt;
&lt;div class=&quot;inner&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/nature&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/animals&quot; alt=&quot;Nature&quot;&gt;
&lt;img src=&quot;http://lorempixel.com/150/150/abstract&quot; alt=&quot;Nature&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;transform-style&lt;/h4&gt;

&lt;p&gt;这个参数用来共享父元素的3D空间，这样说起来有些抽象，下面第一个翻卡片的例子中会讲到。&lt;/p&gt;

&lt;h4&gt;backface-visibility&lt;/h4&gt;

&lt;p&gt;backface-visibility 属性可用于隐藏内容的背面。默认情况下，背面可见，这意味着即使在翻转后，变换的内容仍然可见。但当 backface-visibility 设置为 hidden 时，旋转后内容将隐藏，因为旋转后正面将不再可见。该功能可帮助你模拟多面的对象，例如下例中使用的卡片。通过将 backface-visibility 设置为 hidden，可以确保只有正面可见。&lt;/p&gt;

&lt;h2&gt;CSS3 动画实例&lt;/h2&gt;

&lt;p&gt;下面例子中的代码，为了方便查看都没有写浏览器前缀，也没有加入其他的修饰属性，所以实际应用时，不要忘记哦，当然也可以直接console查看。&lt;/p&gt;

&lt;h3&gt;CSS3 翻纸牌&lt;/h3&gt;

&lt;p&gt;做一个翻纸牌的效果，结构很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;cardflip&quot;&amp;gt;
  &amp;lt;div id=&quot;card1&quot;&amp;gt;
    &amp;lt;div class=&quot;front&quot;&amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;back&quot;&amp;gt;2&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.cardflip&lt;/code&gt;是整个3D效果的容器，&lt;code&gt;#card1&lt;/code&gt;是翻转效果的元素，&lt;code&gt;.front&lt;/code&gt;和&lt;code&gt;.back&lt;/code&gt;是翻转的两面。添加样式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cardflip {
    width: 200px;
    height: 260px;
    position: relative;
    perspective: 800px;
}

#card1 {
    width: 100%;
    height: 100%;
    position: absolute;
    transform-style: preserve-3d;
    transition: transform 1s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先给&lt;code&gt;#cardflip&lt;/code&gt;添加&lt;code&gt;perspective&lt;/code&gt;属性，这样才能触发3D变换，之后&lt;code&gt;#card1&lt;/code&gt;就在父元素的3D空间中了，用了&lt;code&gt;absolute&lt;/code&gt;来定位子元素，设置宽高都是&lt;code&gt;100%&lt;/code&gt;，这样就可以让&lt;code&gt;transform-origin&lt;/code&gt;在元素的中心点，这个后面再讨论。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;transform-style&lt;/code&gt;有两个值，一个是默认的&lt;code&gt;flat&lt;/code&gt;一个是&lt;code&gt;preserve-3d&lt;/code&gt;，由于&lt;code&gt;perspective&lt;/code&gt;的3D空间，只能作用于直接的子元素，那么&lt;code&gt;.front&lt;/code&gt;和&lt;code&gt;.back&lt;/code&gt;也需要&lt;code&gt;#cardflip&lt;/code&gt;的3D空间的话，就需要给&lt;code&gt;#card1&lt;/code&gt;添加这个属性，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#card1 div{
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有&lt;code&gt;#card1 div&lt;/code&gt;元素共享了外层元素的3D空间之后，3D变换的属性才能生效，这时候的&lt;code&gt;backface-visibility&lt;/code&gt;才有效，设置为&lt;code&gt;hidden&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#card1 .front {
    background: red;
}

#card1 .back {
    background: blue;
    transform: rotateY( 180deg );
}

#card1.flipped {
    transform: rotateY( 180deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为设置了&lt;code&gt;backface-visibility&lt;/code&gt;，而&lt;code&gt;.back&lt;/code&gt;默认就是以Y轴旋转了180度，空间想象一下，&lt;code&gt;.back&lt;/code&gt;就转到背面去了，所以&lt;code&gt;hidden&lt;/code&gt;属性生效，就看不到&lt;code&gt;.back&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;#card1&lt;/code&gt;添加了&lt;code&gt;.flipped&lt;/code&gt;的样式，&lt;code&gt;#card1&lt;/code&gt;以Y轴旋转了180度，这时候&lt;code&gt;.front&lt;/code&gt;转到了背面，而&lt;code&gt;.back&lt;/code&gt;从背面转到了前面，所以就完成了切换。这一段需要仔细的想一想。好了，看看下面的实例，点击即可翻转：&lt;/p&gt;

&lt;div id=&quot;cardflip&quot;&gt;
&lt;div id=&quot;card1&quot;&gt;
&lt;div class=&quot;front&quot;&gt;1&lt;/div&gt;
&lt;div class=&quot;back&quot;&gt;2&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;我们再给这个翻转加一些偏移的效果，看起来会不那么生硬。这就用到了&lt;code&gt;transform-origin&lt;/code&gt;，这个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#card1 { transform-origin: left center; }

#card1.flipped {
  transform: translateX( 100% ) rotateY( 180deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认的&lt;code&gt;transform-origin&lt;/code&gt;是&lt;code&gt;center center&lt;/code&gt;，我们改成&lt;code&gt;left center&lt;/code&gt;之后，就不再以元素的x方向的中心为轴旋转，而是以元素的左边为Y轴旋转，所以还需要给整个&lt;code&gt;#card1&lt;/code&gt;加一个位移量&lt;code&gt;translate&lt;/code&gt;，值是&lt;code&gt;100%&lt;/code&gt;，就是元素本身的宽度。&lt;/p&gt;

&lt;p&gt;可以在console里面去掉&lt;code&gt;#card1.flipped&lt;/code&gt;的&lt;code&gt;translate&lt;/code&gt;帮助理解。&lt;/p&gt;

&lt;div id=&quot;cardflip1&quot;&gt;
&lt;div id=&quot;card2&quot;&gt;
&lt;div class=&quot;front&quot;&gt;1&lt;/div&gt;
&lt;div class=&quot;back&quot;&gt;2&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;这里有一点需要注意，当元素在z轴上有了位移，或者朝向负角度旋转，会导致元素在页面上无法被鼠标点击到，想像一下3D空间，这个元素已经位于整个页面平面的&lt;strong&gt;里面&lt;/strong&gt;，所以无法触及了。&lt;/p&gt;

&lt;h3&gt;CSS3 立方体&lt;/h3&gt;

&lt;p&gt;做完了反转卡片的效果，肯定还想做更炫的，来试试做一个立方体吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;section id=&quot;cube-con&quot;&amp;gt;
  &amp;lt;div id=&quot;cube&quot;&amp;gt;
    &amp;lt;figure class=&quot;front&quot;&amp;gt;1&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;back&quot;&amp;gt;2&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;right&quot;&amp;gt;3&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;left&quot;&amp;gt;4&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;top&quot;&amp;gt;5&amp;lt;/figure&amp;gt;
    &amp;lt;figure class=&quot;bottom&quot;&amp;gt;6&amp;lt;/figure&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

#cube-con {
    width: 200px;
    height: 200px;
    position: relative;
    perspective: 1000px;
}

#cube {
    width: 100%;
    height: 100%;
    position: absolute;
    transform-style: preserve-3d;
}

#cube figure {
    width: 196px;
    height: 196px;
    display: block;
    position: absolute;
    border: 2px solid black;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一部分和上一个例子没有太大的差别，应该都能理解每一个属性的含义了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cube .front  { transform: rotateY(   0deg ) translateZ( 100px ); }
#cube .back   { transform: rotateX( 180deg ) translateZ( 100px ); }
#cube .right  { transform: rotateY(  90deg ) translateZ( 100px ); }
#cube .left   { transform: rotateY( -90deg ) translateZ( 100px ); }
#cube .top    { transform: rotateX(  90deg ) translateZ( 100px ); }
#cube .bottom { transform: rotateX( -90deg ) translateZ( 100px ); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立方体的每一个面，经过&lt;code&gt;rotate&lt;/code&gt;旋转之后，就放置在了他该被放置的地方，但是这时候会发现，这些层叠加在一起，还没有成为一个立方体，这时候需要给Z轴一个位移，想象一下我们的视角点在&lt;code&gt;#cube&lt;/code&gt;正中间，拉伸z轴之后，&lt;code&gt;.right&lt;/code&gt;、&lt;code&gt;left&lt;/code&gt;等面就会有一定的角度，参考画画时候的透视，因为刚好在中心点，所以位移量就是宽度的一半。分步过程可以看&lt;a href=&quot;http://desandro.github.io/3dtransforms/examples/cube-01-steps.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;因为z轴拉伸之后，原来的对象会被放大一些，这样就会模糊掉，为了去掉这个影响，我们需要把立方体再推回原来的视角平面，于是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cube { transform: translateZ( -100px ); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成了立方体，想让某个面旋转到前方，只需转动整个立方体，不用去调整每个面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cube.show-front  { transform: translateZ( -100px ) rotateY(    0deg ); }
#cube.show-back   { transform: translateZ( -100px ) rotateX( -180deg ); }
#cube.show-right  { transform: translateZ( -100px ) rotateY(  -90deg ); }
#cube.show-left   { transform: translateZ( -100px ) rotateY(   90deg ); }
#cube.show-top    { transform: translateZ( -100px ) rotateX(  -90deg ); }
#cube.show-bottom { transform: translateZ( -100px ) rotateX(   90deg ); }

/**还有过渡效果**/
#cube { transition: transform 1s; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;section id=&quot;cube-con&quot;&gt;&lt;/p&gt;

&lt;div id=&quot;cube&quot;&gt;
&lt;figure class=&quot;front&quot;&gt;1&lt;/figure&gt;
&lt;figure class=&quot;back&quot;&gt;2&lt;/figure&gt;
&lt;figure class=&quot;right&quot;&gt;3&lt;/figure&gt;
&lt;figure class=&quot;left&quot;&gt;4&lt;/figure&gt;
&lt;figure class=&quot;top&quot;&gt;5&lt;/figure&gt;
&lt;figure class=&quot;bottom&quot;&gt;6&lt;/figure&gt;
&lt;/div&gt;


&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;div id=&quot;cube-btn&quot;&gt;
&lt;button data-class=&quot;show-front&quot;&gt;Show Front&lt;/button&gt;
&lt;button data-class=&quot;show-back&quot;&gt;Show Back&lt;/button&gt;
&lt;button data-class=&quot;show-right&quot;&gt;Show Right&lt;/button&gt;
&lt;button data-class=&quot;show-left&quot;&gt;Show Left&lt;/button&gt;
&lt;button data-class=&quot;show-top&quot;&gt;Show Top&lt;/button&gt;
&lt;button data-class=&quot;show-bottom&quot;&gt;Show Bottom&lt;/button&gt;
&lt;/div&gt;


&lt;h3&gt;3D 旋转跑马灯&lt;/h3&gt;

&lt;p&gt;做幻灯片展示的方法有很多，我们用CSS3的3D技术来试试看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;section class=&quot;container&quot;&amp;gt;
  &amp;lt;div id=&quot;carousel&quot;&amp;gt;
    &amp;lt;figure&amp;gt;1&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;2&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;3&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;4&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;5&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;6&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;7&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;8&amp;lt;/figure&amp;gt;
    &amp;lt;figure&amp;gt;9&amp;lt;/figure&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

.container {
  width: 210px;
  height: 140px;
  position: relative;
  perspective: 1000px;
}

#carousel {
  width: 100%;
  height: 100%;
  position: absolute;
  transform-style: preserve-3d;
}

#carousel figure {
  display: block;
  position: absolute;
  width: 186px;
  height: 116px;
  left: 10px;
  top: 10px;
  border: 2px solid black;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这一段，没什么特别要说明的，基本的结构样式，以及之前重点说明过的&lt;code&gt;perspective&lt;/code&gt;和&lt;code&gt;preserve-3d&lt;/code&gt;。现在有9个卡片，要环绕成一圈，那么每个的角度就是&lt;code&gt;40deg&lt;/code&gt; （360/90）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#carousel figure:nth-child(1) { transform: rotateY(   0deg ); }
#carousel figure:nth-child(2) { transform: rotateY(  40deg ); }
#carousel figure:nth-child(3) { transform: rotateY(  80deg ); }
#carousel figure:nth-child(4) { transform: rotateY( 120deg ); }
#carousel figure:nth-child(5) { transform: rotateY( 160deg ); }
#carousel figure:nth-child(6) { transform: rotateY( 200deg ); }
#carousel figure:nth-child(7) { transform: rotateY( 240deg ); }
#carousel figure:nth-child(8) { transform: rotateY( 280deg ); }
#carousel figure:nth-child(9) { transform: rotateY( 320deg ); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，和立方体的例子到同样的步骤了，现在所有的卡片做了Y轴旋转，但因为观察的视角点没有变，所以看起来还是平面，如下这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/8b8af2c8jw1e84s4cel0uj208e05raa0.jpg&quot; alt=&quot;caro&quot; /&gt;&lt;/p&gt;

&lt;p&gt;立方体的位移很好计算，只要是宽度、高度、或者深度的一半就可以了，这个旋转的跑马灯应该怎么计算呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8b8af2c8jw1e84s5efyxej20f00b6aaj.jpg&quot; alt=&quot;caro-cmpu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从旋转跑马灯的上方观察，每个卡片的宽度是&lt;code&gt;210px&lt;/code&gt;，角度是&lt;code&gt;40deg&lt;/code&gt;，要计算到中心点的距离，根据旁边的三角形可得：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r = 105 / tan(20deg) = 288px
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#carousel figure:nth-child(1) {transform:rotateY(  0deg) translateZ(288px);}
#carousel figure:nth-child(2) {transform:rotateY( 40deg) translateZ(288px);}
#carousel figure:nth-child(3) {transform:rotateY( 80deg) translateZ(288px);}
#carousel figure:nth-child(4) {transform:rotateY(120deg) translateZ(288px);}
#carousel figure:nth-child(5) {transform:rotateY(160deg) translateZ(288px);}
#carousel figure:nth-child(6) {transform:rotateY(200deg) translateZ(288px);}
#carousel figure:nth-child(7) {transform:rotateY(240deg) translateZ(288px);}
#carousel figure:nth-child(8) {transform:rotateY(280deg) translateZ(288px);}
#carousel figure:nth-child(9) {transform:rotateY(320deg) translateZ(288px);}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道了计算方法，如果要改变卡片的个数，或者宽度，只要按照那个公式再计算就好：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var tz = Math.round( ( panelSize / 2 ) / 
  Math.tan( ( ( Math.PI * 2 ) / numberOfPanels ) / 2 ) );
// or simplified to
var tz = Math.round( ( panelSize / 2 ) / 
  Math.tan( Math.PI / numberOfPanels ) );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算好卡片的位置之后，然后旋转&lt;code&gt;#carousel&lt;/code&gt;就可以了，当然这个要用js来控制了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#carousel{
    transform: translateZ( -288px ) rotateY( -160deg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(function(){
    $(&#39;#car-pre&#39;).click(function(){
        var deg = $(&#39;#carousel&#39;).attr(&#39;data-deg&#39;) || 0;
        deg = parseInt(deg)+40;

        var value = &#39;translateZ(-288px) rotateY(&#39;+deg+&#39;deg)&#39;;

        $(&#39;#carousel&#39;)
            .attr(&#39;data-deg&#39;,deg)
            .css({
                &#39;-webkit-transform&#39;:value
                ,&#39;-moz-transform&#39;:value
                ,&#39;-o-transform&#39;:value
                ,&#39;transform&#39;:value
            });
    });
    $(&#39;#car-next&#39;).click(function(){
        var deg = $(&#39;#carousel&#39;).attr(&#39;data-deg&#39;) || 0;
        deg = parseInt(deg)-40;

        var value = &#39;translateZ(-288px) rotateY(&#39;+deg+&#39;deg)&#39;;

        $(&#39;#carousel&#39;)
            .attr(&#39;data-deg&#39;,deg)
            .css({
                &#39;-webkit-transform&#39;:value
                ,&#39;-moz-transform&#39;:value
                ,&#39;-o-transform&#39;:value
                ,&#39;transform&#39;:value
            });
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;section id=&quot;caro-con&quot;&gt;&lt;div id=&quot;carousel&quot;&gt;&lt;figure&gt;1&lt;/figure&gt;&lt;figure&gt;2&lt;/figure&gt;&lt;figure&gt;3&lt;/figure&gt;&lt;figure&gt;4&lt;/figure&gt;&lt;figure&gt;5&lt;/figure&gt;&lt;figure&gt;6&lt;/figure&gt;&lt;figure&gt;7&lt;/figure&gt;&lt;figure&gt;8&lt;/figure&gt;&lt;figure&gt;9&lt;/figure&gt;&lt;/div&gt;&lt;/section&gt;&lt;/p&gt;

&lt;div id=&quot;car-btn&quot;&gt;
&lt;button id=&quot;car-pre&quot;&gt;&amp;lt; Prev&lt;/button&gt;
&lt;button id=&quot;car-next&quot;&gt;Next &amp;gt;&lt;/button&gt;
&lt;/div&gt;


&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;终于完成了这篇，梳理的过程对我自己很有提高，希望对你也能有些帮助，有兴趣可以关注我，期待下以后的博客~&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Grunt.js 在前端项目中的实战</title>
     <link href="http://blog.11010.net/grunt-in-action"/>
     <updated>2013-07-17T00:00:00+08:00</updated>
     <id>http://beiyuu.com/grunt-in-action</id>
     <content type="html">&lt;h2&gt;Grunt是什么？&lt;/h2&gt;

&lt;p&gt;Grunt已经out了，请用&lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp&lt;/a&gt;，参考这篇：&lt;a href=&quot;http://www.smashingmagazine.com/2014/06/11/building-with-gulp/&quot;&gt;Building with Gulp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;&lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt;是一个基于JavaScript的任务运行工具。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;为什么要使用Grunt，简而言之是为了“自动”，用工具自动完成压缩、编译、单元测试、拼写检查等重复性工作。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;Grunt的社区壮大非常快，现在支持的模块有：&lt;a href=&quot;http://coffeescript.org/&quot;&gt;CoffeeScript&lt;/a&gt;、 &lt;a href=&quot;http://handlebarsjs.com/&quot;&gt;handlerbars&lt;/a&gt;、 &lt;a href=&quot;http://jade-lang.com/&quot;&gt;jade&lt;/a&gt;、 &lt;a href=&quot;http://www.jshint.com/&quot;&gt;JSHint&lt;/a&gt;、 &lt;a href=&quot;http://lesscss.org/&quot;&gt;Less&lt;/a&gt;、 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;、 &lt;a href=&quot;http://sass-lang.com/&quot;&gt;Sass&lt;/a&gt;、 &lt;a href=&quot;http://learnboost.github.io/stylus/&quot;&gt;stylus&lt;/a&gt;等。&lt;/del&gt;&lt;/p&gt;

&lt;h2&gt;Grunt基本配置&lt;/h2&gt;

&lt;p&gt;Grunt及其插件都是用&lt;a href=&quot;https://npmjs.org/&quot;&gt;npm&lt;/a&gt;管理的，npm是&lt;a href=&quot;http://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;的包管理程序，所以在使用Grunt之前，你需要先安装NodeJS。&lt;/p&gt;

&lt;h3&gt;安装CLI&lt;/h3&gt;

&lt;p&gt;首先需要在全局环境中安装Grunt command line interface (CLI)，在Mac等系统中需要sudo来执行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g grunt-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会将&lt;code&gt;grunt&lt;/code&gt;命令安装在系统path中，这样就可以从任何目录执行了。需要注意的是，安装了&lt;code&gt;grunt-cli&lt;/code&gt;并没有安装任务管理工具。&lt;code&gt;CLI&lt;/code&gt;的职责很简单，就是运行&lt;code&gt;Gruntfile&lt;/code&gt;中定义的&lt;code&gt;Grunt&lt;/code&gt;版本，这样你就可以在一台机器运行多个版本的Grunt。&lt;/p&gt;

&lt;p&gt;如果从0.3版本升级，需要先卸载旧版：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm uninstall -g grunt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;已存在Grunt的项目&lt;/h2&gt;

&lt;p&gt;对于已经使用了Grunt的项目，搭建本地环境是非常方便的，只需要切换到该项目目录，然后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再使用&lt;code&gt;grunt&lt;/code&gt;命令运行Grunt即可。&lt;/p&gt;

&lt;h2&gt;新建Grunt项目&lt;/h2&gt;

&lt;p&gt;最基本的步骤就是给项目添加两个文件&lt;code&gt;package.json&lt;/code&gt;和&lt;code&gt;Gruntfile&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;package.json&lt;/code&gt;：在这个文件里你可以列出项目所需的Grunt插件，npm会自动下载。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Grunfile&lt;/code&gt;：这个文件命名为&lt;code&gt;Gruntfile.js&lt;/code&gt;或者&lt;code&gt;Gruntfile.coffee&lt;/code&gt;，用来描述你所需要的grunt任务。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;package.json&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;文件需要放置在项目的根目录，和代码一起提交。运行&lt;code&gt;npm install&lt;/code&gt;命令，会安装&lt;code&gt;package.json&lt;/code&gt;中列出的依赖插件的正确版本。&lt;/p&gt;

&lt;p&gt;创建&lt;code&gt;package.json&lt;/code&gt;有以下几种办法：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;大部分&lt;code&gt;grunt-init&lt;/code&gt;模板，会创建项目相关的&lt;code&gt;package.json&lt;/code&gt;文件&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;npm init&lt;/code&gt;命令会创建基本的&lt;code&gt;package.json&lt;/code&gt;文件&lt;/li&gt;
    &lt;li&gt;也可以下面这个范本创建，更多用法可以看&lt;a href=&quot;https://npmjs.org/doc/json.html&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;specification&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;{
    &quot;name&quot;: &quot;my-project-name&quot;,
    &quot;version&quot;: &quot;0.1.0&quot;,
    &quot;devDependencies&quot;: {
        &quot;grunt&quot;: &quot;~0.4.1&quot;,
        &quot;grunt-contrib-jshint&quot;: &quot;~0.6.0&quot;,
        &quot;grunt-contrib-nodeunit&quot;: &quot;~0.2.0&quot;,
        &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装Grunt和插件&lt;/h3&gt;

&lt;p&gt;对于已存在&lt;code&gt;package.json&lt;/code&gt;文件的项目，最简单的安装方法就是&lt;code&gt;npm install &amp;lt;module&amp;gt; --save-dev&lt;/code&gt;，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会安装最新版的&lt;code&gt;grunt&lt;/code&gt;，并且把对这个插件的依赖写入&lt;code&gt;package.json&lt;/code&gt;。很方便。&lt;/p&gt;

&lt;h2&gt;Gruntfile&lt;/h2&gt;

&lt;p&gt;和&lt;code&gt;package.json&lt;/code&gt;文件一样，&lt;code&gt;Gruntfile.js&lt;/code&gt;或者&lt;code&gt;Gruntfile.coffee&lt;/code&gt;需要放在根目录下和源码一起提交。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gruntfile&lt;/code&gt;由以下几个部分组成：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;wrapper&lt;/code&gt;函数&lt;/li&gt;
    &lt;li&gt;项目和任务配置&lt;/li&gt;
    &lt;li&gt;加载Grunt插件和任务&lt;/li&gt;
    &lt;li&gt;自定义任务&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;示例Gruntfile&lt;/h3&gt;

&lt;p&gt;在下面这个例子中，项目信息引自&lt;code&gt;package.json&lt;/code&gt;，grunt-contrib-uglify插件的&lt;code&gt;uglify&lt;/code&gt;任务用来压缩js文件，并且根据项目的metadata生成一条注释。当grunt运行时，uglify任务会默认执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt) {

  // Project configuration.
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    uglify: {
      options: {
        banner: &#39;/*! &amp;lt;%= pkg.name %&amp;gt; &amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */\n&#39;
      },
      build: {
        src: &#39;src/&amp;lt;%= pkg.name %&amp;gt;.js&#39;,
        dest: &#39;build/&amp;lt;%= pkg.name %&amp;gt;.min.js&#39;
      }
    }
  });

  // Load the plugin that provides the &quot;uglify&quot; task.
  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);

  // Default task(s).
  grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是一个完整的&lt;code&gt;Gruntfile&lt;/code&gt;，我们仔细研究下。&lt;/p&gt;

&lt;h3&gt;wrapper函数&lt;/h3&gt;

&lt;p&gt;每个&lt;code&gt;Gruntfile&lt;/code&gt;（包括插件）使用这个默认的格式，你的所有的Grunt代码也必须写在这个函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.export = function(grunt){
    //Do grunt-related things in here
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;项目和任务配置&lt;/h3&gt;

&lt;p&gt;大多Grunt的任务依赖于&lt;a href=&quot;http://gruntjs.com/grunt#grunt.initconfig&quot;&gt;grunt.initConfig&lt;/a&gt;方法中定义的配置。&lt;/p&gt;

&lt;p&gt;在这个例子中，Grunt通过&lt;code&gt;grunt.file.readJSON(&#39;package.json&#39;)&lt;/code&gt;引入了&lt;code&gt;package.json&lt;/code&gt;中定义的Grunt配置。因为&lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;模板变量可以引用任何配置，所以像文件路径、文件列表这些内容应该存储在变量中，以减少重复。&lt;/p&gt;

&lt;p&gt;和其他任务一样，任务的配置需要和任务名字一样的变量，具体的参数可以查询各任务的文档。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Project configuration.
grunt.initConfig({
  pkg: grunt.file.readJSON(&#39;package.json&#39;),
  uglify: {
    options: {
      banner: &#39;/*! &amp;lt;%= pkg.name %&amp;gt; &amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */\n&#39;
    },
    build: {
      src: &#39;src/&amp;lt;%= pkg.name %&amp;gt;.js&#39;,
      dest: &#39;build/&amp;lt;%= pkg.name %&amp;gt;.min.js&#39;
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;加载Grunt的插件和任务&lt;/h3&gt;

&lt;p&gt;很多常用的任务比如&lt;a href=&quot;https://github.com/gruntjs/grunt-contrib-concat&quot;&gt;concatenation&lt;/a&gt;、 &lt;a href=&quot;http://github.com/gruntjs/grunt-contrib-uglify&quot;&gt;minification&lt;/a&gt;、 &lt;a href=&quot;https://github.com/gruntjs/grunt-contrib-jshint&quot;&gt;linting&lt;/a&gt;都有&lt;a href=&quot;https://github.com/gruntjs&quot;&gt;Grung插件&lt;/a&gt;。只要在&lt;code&gt;package.json&lt;/code&gt;中声明，然后通过&lt;code&gt;npm install&lt;/code&gt;安装，就可以在&lt;code&gt;Gruntfile&lt;/code&gt;中配置使用了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Load the plugin that provides the &quot;uglify&quot; task.
grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;grunt --help&lt;/code&gt;可以查看所有可用的任务。&lt;/p&gt;

&lt;h3&gt;自定义任务&lt;/h3&gt;

&lt;p&gt;你可以配置让Grunt运行一个或多个默认任务。在例子中，运行&lt;code&gt;grunt&lt;/code&gt;不带任何参数就会执行&lt;code&gt;uglify&lt;/code&gt;任务。这和&lt;code&gt;grunt uglify&lt;/code&gt;或者&lt;code&gt;grunt default&lt;/code&gt;是一样的效果。数组的长度任意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Default task(s).
grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要的任务并没有插件提供，那么也可以自定义，自定义的任务可以不写任务配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt) {

  // A very basic default task.
  grunt.registerTask(&#39;default&#39;, &#39;Log some stuff.&#39;, function() {
    grunt.log.write(&#39;Logging some stuff...&#39;).ok();
  });

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义的任务也不必一定写在&lt;code&gt;Gruntfile&lt;/code&gt;中，也可以定义在外部的&lt;code&gt;.js&lt;/code&gt;文件中，然后通过&lt;a href=&quot;http://gruntjs.com/grunt#grunt.loadtasks&quot;&gt;grunt.loadTasks&lt;/a&gt;来加载。&lt;/p&gt;

&lt;h2&gt;实战&lt;/h2&gt;

&lt;p&gt;grunt插件中有contrib前缀的是Grunt团队自行开发的插件，也是推荐使用的，下面挑选几个在前端项目中必用的插件，在实际例子中介绍一下使用方法。&lt;/p&gt;

&lt;h3&gt;grunt-contrib-compass&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://compass-style.org/&quot;&gt;Compass&lt;/a&gt;是&lt;a href=&quot;http://sass-lang.com/&quot;&gt;SASS&lt;/a&gt;的一个框架，就像jQuery之于Javascript、Rails之于Ruby。具体的用法可以参考阮一峰的这两篇Blog:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/06/sass.html&quot;&gt;SASS用法指南&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/11/compass.html&quot;&gt;Compass用法指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;首先，安装&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-compass&quot;&gt;grunt-contrib-compass&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt-contrib-compass --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如前所述，&lt;code&gt;--save-dev&lt;/code&gt;可以在安装插件的过程中，将对这个插件的依赖自动写入&lt;code&gt;package.json&lt;/code&gt;文件中，方便。&lt;/p&gt;

&lt;p&gt;Compass并没有暴露所有的设置给Grunt，如果有别的需要，可以在config里面指定&lt;code&gt;config.rb&lt;/code&gt;给Compass编译使用。看一个配置的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt){
    grunt.initConfig({
      compass: {                  // compass任务
        dist: {                   // 一个子任务
          options: {              // 任务的设置
            sassDir: &#39;sass&#39;,
            cssDir: &#39;css&#39;,
            environment: &#39;production&#39;
          }
        },
        dev: {                    // 另一个子任务
          options: {
            sassDir: &#39;sass&#39;,
            cssDir: &#39;style&#39;
          }
        }
      }
    });

    grunt.loadNpmTasks(&#39;grunt-contrib-compass&#39;);

    grunt.registerTask(&#39;default&#39;, [&#39;compass&#39;]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要使用外部文件的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.initConfig({
  compass: {
    dist: {
      options: {
        config: &#39;config/config.rb&#39;
      }
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;grunt-contrib-concat&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-concat&quot;&gt;grunt-contrib-concat&lt;/a&gt;是一个合并文件的插件，可以将多个css或js文件合并为一个，以节省链接数。同样的，安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt-contrib-concat --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个插件有一下几个常用配置：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;seperator&lt;/code&gt;：被合并的文件会用这个参数来join，例如你在合并压缩后的js文件时，可以加个&lt;code&gt;;&lt;/code&gt;防止出错&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;banner&lt;/code&gt;：在合并后的文件头部加一些额外信息&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;footer&lt;/code&gt;：在合并后的文件尾部加一些额外信息&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;再看一下用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.initConfig({
  pkg: grunt.file.readJSON(&#39;package.json&#39;),
  concat: {
    options: {                                                      //配置
      stripBanners: true,
      banner: &#39;/*! &amp;lt;%= pkg.name %&amp;gt; - v&amp;lt;%= pkg.version %&amp;gt; - &#39; +      //添加自定义的banner
        &#39;&amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */&#39;
    },
    dist: {                                                         //任务
        src: [&#39;src/intro.js&#39;, &#39;src/project.js&#39;, &#39;src/outro.js&#39;],    //源目录文件
        dest: &#39;dist/built.js&#39;                                       //合并后的文件
    },
    basic_and_extras: {                                             //另一个任务
        files: {                                                    //另一种更简便的写法
            &#39;dist/basic.js&#39;: [&#39;src/main.js&#39;],
            &#39;dist/with_extras.js&#39;: [&#39;src/main.js&#39;, &#39;src/extras.js&#39;]
        }
    }
  }
});

grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后在&lt;code&gt;default&lt;/code&gt;事件中添加&lt;code&gt;concat&lt;/code&gt;就会默认执行了。&lt;/p&gt;

&lt;h3&gt;grunt-contrib-uglify&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-uglify&quot;&gt;grunt-contrib-uglify&lt;/a&gt;用来压缩js文件，用法与&lt;code&gt;concat&lt;/code&gt;类似，先安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt-contrib-uglify --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后写入相应的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.initConfig({
  uglify: {
    options: {
      banner: &#39;/*! This is uglify test - &#39; +
        &#39;&amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */&#39;
    },
    app_task: {
      files: {
        &#39;dist/app.min.js&#39;: [&#39;js/app.js&#39;, &#39;js/render.js&#39;]
      }
    }
  }
});

grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恩，经过如此处理，你的js代码已经丑陋到无法直视了。&lt;/p&gt;

&lt;h3&gt;grunt-contrib-watch&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-watch&quot;&gt;grunt-contrib-watch&lt;/a&gt;是开发必备插件，用来监控文件的修改，然后自动运行grunt任务，省去一遍遍手动执行Grunt命令，安装照旧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt-contrib-watch --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用watch插件时，需要注意一点，被watch的文件，可以分开写，这样可以提高watch的性能，不用每次把没修改的文件也执行一遍任务，看看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.initConfig({
  watch: {
    css: {
      files: [&#39;public/scss/*.scss&#39;],
      tasks: [&#39;compass&#39;],
      options: {
        // Start a live reload server on the default port 35729
        livereload: true,
      },
    },
    another: {
      files: [&#39;lib/*.js&#39;],
      tasks: [&#39;anothertask&#39;],
      options: {
        // Start another live reload server on port 1337
        livereload: 1337,
      },
    }
  }
});

grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行&lt;code&gt;grunt watch&lt;/code&gt;命令，修改文件，就会看到设定的任务执行了。&lt;/p&gt;

&lt;h2&gt;源码&lt;/h2&gt;

&lt;p&gt;Grunt的基本使用就是这些了，当然还有一些&lt;a href=&quot;http://gruntjs.com/project-scaffolding&quot;&gt;搭建脚手架&lt;/a&gt;等等的功能，等待你自己去学习使用吧，更多的&lt;a href=&quot;http://gruntjs.com/plugins/&quot;&gt;Grunt 插件&lt;/a&gt;也等待你去发现。&lt;/p&gt;

&lt;p&gt;贴出来源码，整体看一下：&lt;/p&gt;

&lt;h3&gt;package.json&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;Grunt-in-action&quot;,
  &quot;devDependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.1&quot;,
    &quot;grunt-contrib-compass&quot;: &quot;~0.3.0&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.4.4&quot;,
    &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,
    &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Gruntfile.js&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt){
    grunt.initConfig({
        compass: {                  // Task
            dist: {                   // Target
                options: {              // Target options
                    sassDir: &#39;sass&#39;,
                    cssDir: &#39;css&#39;,
                    environment: &#39;production&#39;
                }
            },
            dev: {                    // Another target
                options: {
                    sassDir: &#39;sass&#39;,
                    cssDir: &#39;style&#39;
                }
            }
        },

        concat: {
            options: {                                       //配置
                stripBanners:true,
                banner: &#39;/*! This is the grunt test &#39; +      //添加自定义的banner
                &#39;&amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */&#39;
            },
            basic: {                                         //另一个任务
                files: {                                     //另一种更简便的写法
                    &#39;dist/style.css&#39;: [&#39;style/screen.css&#39;,&#39;style/ie.css&#39;,&#39;style/print.css&#39;]
                }
            }
        },

        uglify: {
            options: {
                banner: &#39;/*! This is uglify test - &#39; +
                &#39;&amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt; */&#39;
            },
            app_task: {
                files: {
                    &#39;dist/app.min.js&#39;: [&#39;js/app.js&#39;, &#39;js/render.js&#39;]
                }
            }
        },

        watch: {
            css: {
                files: [&#39;sass/*.scss&#39;],
                tasks: [&#39;compass&#39;, &#39;concat&#39;]
            },
            another: {
                files: [&#39;js/*.js&#39;],
                tasks: [&#39;uglify&#39;]
            }
        }
    });

    grunt.loadNpmTasks(&#39;grunt-contrib-compass&#39;);
    grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);
    grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);
    grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);

    grunt.registerTask(&#39;default&#39;, [&#39;compass&#39;,&#39;concat&#39;, &#39;uglify&#39;]);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>史蒂夫·乔布斯：遗失的访谈</title>
     <link href="http://blog.11010.net/jobs-interview"/>
     <updated>2013-05-14T00:00:00+08:00</updated>
     <id>http://beiyuu.com/jobs-interview</id>
     <content type="html">&lt;h2&gt;1、做公司就是做产品&lt;/h2&gt;

&lt;p&gt;乔布斯从12岁开始，就捣鼓着好玩有用的产品，在惠普兼职的那些日子，也让他体会到了科技的魅力，原来凭一个人的力量也可以有如此之大的影响力，也是在惠普他认识了沃兹尼亚克。&lt;/p&gt;

&lt;p&gt;Apple II发布时，乔布斯年仅21岁，从此之后，他的财富不断增加，23岁一百万，24岁一千万，25岁一亿美元。但是钱并不是乔布斯认为最重要的东西，重要的是人才、产品，是产品带给用户的价值。&lt;/p&gt;

&lt;p&gt;做产品要深入的每一个细节，要去控制成本，就必须知道每一个步骤的精确成本，他也建议所有人都去学习一下编程，学习这种思考问题的方式。&lt;/p&gt;

&lt;p&gt;乔布斯举了百事可乐的例子，来说明大公司为什么会失败，因为一旦公司做大，形成垄断市场之后，产品数十年也不会发生多大的变化，而且这些垄断的市场也很难再提高业绩，要提高业绩还得靠营销部门，最终营销人员挤走了产品人员，而营销人员并不懂产品，这情形在百事可乐这样的公司没问题，但在科技公司就会造成悲剧。&lt;/p&gt;

&lt;p&gt;光靠流程和制度，是不能让公司持续成功的，必须全心全意放在产品上。&lt;/p&gt;

&lt;h2&gt;2、如何使公司良好运转&lt;/h2&gt;

&lt;p&gt;对于传统行业来说，最好和普通之间，差距可能就是百分之几十的样子，但是对科技行业来说，最好的与普通的人才，能力的差距可能达百倍，所以一流的公司需要一流的人才，一流的人才也愿意与一流的人才共事。&lt;/p&gt;

&lt;p&gt;团队的协作过程，就像磨石机的工作过程一样，会有摩擦会有障碍，这是必然的，以乔布斯的理解来看，真正优秀的人，只想成功，不在乎是非，用事实说话，其他的都不重要，他认为优秀的人也不太需要你太在乎他们的自尊。&lt;/p&gt;

&lt;p&gt;大约这就是他被谣传暴戾的原因吧，从访谈中可以看的出，他确实不太在乎事实之外的东西，他自己也会犯错，别人也可以说服他，只要基于事实就好。&lt;/p&gt;

&lt;h2&gt;3、品位问题&lt;/h2&gt;

&lt;p&gt;毫无疑问，乔布斯的品位很好，他认为和在大学时旁听排版课程的关系密不可分，的确，内容永远都是最重要的，并且，字体设计那些细致入微的细节，也对他有很深的影响。&lt;/p&gt;

&lt;p&gt;微软是一个成功的公司，善于抓住机遇，但是他们的产品毫无品位，是三流的，或许没有苹果，微软的产品会更糟糕，没有灵魂，非常平庸，但是更令人可悲的是用户并不以为然。&lt;/p&gt;

&lt;p&gt;人类应该追求极致，并分享给同类。&lt;/p&gt;

&lt;p&gt;乔布斯也从来不觉得借鉴别人的创意是可耻的，笨拙的工匠只会抄，灵巧的工匠会借鉴的恰到好处，苹果的产品非常确切的说明了这个事实。&lt;/p&gt;

&lt;p&gt;6、70年代的嬉皮士运动给乔布斯留下了深刻印象，他认为嬉皮士是去努力寻找生活的真相的一群人，他们觉得生活不应该是父母过的那样。嬉皮士的出发点是可贵的。也正是因为这种精神，有人宁愿当诗人也不愿做银行家。&lt;/p&gt;

&lt;p&gt;乔布斯很欣赏这种精神，他也想把这种精神溶入到产品中。只要用户使用产品，就能感受到这种精神，如果与Macintosh的用户交谈，会发现他们喜爱这个产品，在此之前，你很少听人说真心喜欢某个商业产品——是的，但你可以从Macintosh感受到某种奇妙的东西。&lt;/p&gt;

&lt;!--&lt;iframe height=&quot;498&quot; width=&quot;510&quot; src=&quot;http://player.youku.com/embed/XNTUxNDY1NDY4&quot; frameborder=&quot;0&quot; style=&quot;margin:0 auto&quot;&gt;&lt;/iframe&gt;--&gt;




&lt;div style=&quot;text-align:center&quot;&gt;
&lt;embed src=&quot;http://player.youku.com/player.php/sid/XNTUxNDY1NDY4/v.swf&quot; allowFullScreen=&quot;true&quot; quality=&quot;high&quot; width=&quot;480&quot; height=&quot;400&quot; align=&quot;middle&quot; allowScriptAccess=&quot;always&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/embed&gt;
&lt;/div&gt;

</content>
   </entry>
   
   <entry>
     <title>编写可读代码的艺术</title>
     <link href="http://blog.11010.net/readable-code"/>
     <updated>2013-03-21T00:00:00+08:00</updated>
     <id>http://beiyuu.com/readable-code</id>
     <content type="html">&lt;p&gt;这是《The Art of Readable Code》的读书笔记，再加一点自己的认识。强烈推荐此书：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;英文版：&lt;a href=&quot;http://book.douban.com/subject/5442971/&quot; title=&quot;The Art Of Readable Code&quot;&gt;《The Art of Readable Code》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文版：&lt;a href=&quot;http://book.douban.com/subject/10797189/&quot; title=&quot;编写可读代码的艺术&quot;&gt;编写可读代码的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;代码为什么要易于理解&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;&quot;Code should be written to minimize the time it would take for someone else to understand it.&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;日常工作的事实是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写代码前的思考和看代码的时间远大于真正写的时间&lt;/li&gt;
&lt;li&gt;读代码是很平常的事情，不论是别人的，还是自己的，半年前写的可认为是别人的代码&lt;/li&gt;
&lt;li&gt;代码可读性高，很快就可以理解程序的逻辑，进入工作状态&lt;/li&gt;
&lt;li&gt;行数少的代码不一定就容易理解&lt;/li&gt;
&lt;li&gt;代码的可读性与程序的效率、架构、易于测试一点也不冲突&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;整本书都围绕“如何让代码的可读性更高”这个目标来写。这也是好代码的重要标准之一。&lt;/p&gt;

&lt;h2&gt;如何命名&lt;/h2&gt;

&lt;h3&gt;变量名中应包含更多信息&lt;/h3&gt;

&lt;h4&gt;使用含义明确的词，比如用&lt;code&gt;download&lt;/code&gt;而不是&lt;code&gt;get&lt;/code&gt;，参考以下替换方案：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt; send -&amp;gt; deliver, dispatch, announce, distribute, route
 find -&amp;gt; search, extract, locate, recover
start -&amp;gt; lanuch, create, begin, open
 make -&amp;gt; create,set up, build, generate, compose, add, new
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;避免通用的词&lt;/h4&gt;

&lt;p&gt;像&lt;code&gt;tmp&lt;/code&gt;和&lt;code&gt;retval&lt;/code&gt;这样词，除了说明是临时变量和返回值之外，没有任何意义。但是给他加一些有意义的词，就会很明确：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmp_file = tempfile.NamedTemporaryFile() 
...
SaveData(tmp_file, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不使用retval而使用变量真正代表的意义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sum_squares += v[i]; // Where&#39;s the &quot;square&quot; that we&#39;re summing? Bug!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嵌套的for循环中,&lt;code&gt;i&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;也有同样让人困惑的时候：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; clubs.size(); i++)
    for (int j = 0; j &amp;lt; clubs[i].members.size(); j++)
        for (int k = 0; k &amp;lt; users.size(); k++) if (clubs[i].members[k] == users[j])
            cout &amp;lt;&amp;lt; &quot;user[&quot; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &quot;] is in club[&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;]&quot; &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换一种写法就会清晰很多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; if (clubs[ci].members[mi] == users[ui])  # OK. First letters match.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，当使用一些通用的词，要有充分的理由才可以。&lt;/p&gt;

&lt;h4&gt;使用具体的名字&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;CanListenOnPort&lt;/code&gt;就比&lt;code&gt;ServerCanStart&lt;/code&gt;好，can start比较含糊，而listen on port确切的说明了这个方法将要做什么。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--run_locally&lt;/code&gt;就不如&lt;code&gt;--extra_logging&lt;/code&gt;来的明确。&lt;/p&gt;

&lt;h4&gt;增加重要的细节，比如变量的单位&lt;code&gt;_ms&lt;/code&gt;，对原始字符串加&lt;code&gt;_raw&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;如果一个变量很重要，那么在名字上多加一些额外的字就会更加易读，比如将&lt;code&gt;string id; // Example: &quot;af84ef845cd8&quot;&lt;/code&gt;换成&lt;code&gt;string hex_id;&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;             Start(int delay)  --&amp;gt;  delay → delay_secs
        CreateCache(int size)  --&amp;gt;  size → size_mb
ThrottleDownload(float limit)  --&amp;gt;  limit → max_kbps
          Rotate(float angle)  --&amp;gt;  angle → degrees_cw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;password  -&amp;gt;  plaintext_password
 comment  -&amp;gt;  unescaped_comment
    html  -&amp;gt;  html_utf8
    data  -&amp;gt;  data_urlenc
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;对于作用域大的变量使用较长的名字&lt;/h4&gt;

&lt;p&gt;在比较小的作用域内，可以使用较短的变量名，在较大的作用域内使用的变量，最好用长一点的名字，编辑器的自动补全都可以很好的减少键盘输入。对于一些缩写前缀，尽量选择众所周知的(如str)，一个判断标准是，当新成员加入时，是否可以无需他人帮助而明白前缀代表什么。&lt;/p&gt;

&lt;h4&gt;合理使用&lt;code&gt;_&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;等符号，比如对私有变量加&lt;code&gt;_&lt;/code&gt;前缀。&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var x = new DatePicker(); // DatePicker() 是类的&quot;构造&quot;函数，大写开始
var y = pageHeight(); // pageHeight() 是一个普通函数

var $all_images = $(&quot;img&quot;); // $all_images 是jQuery对象
var height = 250; // height不是

//id和class的写法分开
&amp;lt;div id=&quot;middle_column&quot; class=&quot;main-content&quot;&amp;gt; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;命名不能有歧义&lt;/h3&gt;

&lt;p&gt;命名的时候可以先想一下，我要用的这个词是否有别的含义。举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;results = Database.all_objects.filter(&quot;year &amp;lt;= 2011&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在的结果到底是包含2011年之前的呢还是不包含呢？&lt;/p&gt;

&lt;h4&gt;使用&lt;code&gt;min&lt;/code&gt;、&lt;code&gt;max&lt;/code&gt;代替&lt;code&gt;limit&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;CART_TOO_BIG_LIMIT = 10
    if shopping_cart.num_items() &amp;gt;= CART_TOO_BIG_LIMIT:
        Error(&quot;Too many items in cart.&quot;)

MAX_ITEMS_IN_CART = 10
    if shopping_cart.num_items() &amp;gt; MAX_ITEMS_IN_CART:
     Error(&quot;Too many items in cart.&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对比上例中&lt;code&gt;CART_TOO_BIG_LIMIT&lt;/code&gt;和&lt;code&gt;MAX_ITEMS_IN_CART&lt;/code&gt;，想想哪个更好呢？&lt;/p&gt;

&lt;h4&gt;使用&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;last&lt;/code&gt;来表示闭区间&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;print integer_range(start=2, stop=4)
# Does this print [2,3] or [2,3,4] (or something else)?

set.PrintKeys(first=&quot;Bart&quot;, last=&quot;Maggie&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;last&lt;/code&gt;含义明确，适宜表示闭区间。&lt;/p&gt;

&lt;h4&gt;使用&lt;code&gt;beigin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;表示前闭后开([2,9))区间&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;PrintEventsInRange(&quot;OCT 16 12:00am&quot;, &quot;OCT 17 12:00am&quot;)

PrintEventsInRange(&quot;OCT 16 12:00am&quot;, &quot;OCT 16 11:59:59.9999pm&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面一种写法就比下面的舒服多了。&lt;/p&gt;

&lt;h4&gt;Boolean型变量命名&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;bool read_password = true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个很危险的命名，到底是需要读取密码呢，还是密码已经被读取呢，不知道，所以这个变量可以使用&lt;code&gt;user_is_authenticated&lt;/code&gt;代替。通常，给Boolean型变量添加&lt;code&gt;is&lt;/code&gt;、&lt;code&gt;has&lt;/code&gt;、&lt;code&gt;can&lt;/code&gt;、&lt;code&gt;should&lt;/code&gt;可以让含义更清晰，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;             SpaceLeft()  --&amp;gt;  hasSpaceLeft()
bool disable_ssl = false  --&amp;gt;  bool use_ssl = true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;符合预期&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public class StatisticsCollector {
    public void addSample(double x) { ... }
    public double getMean() {
        // Iterate through all samples and return total / num_samples
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，&lt;code&gt;getMean&lt;/code&gt;方法遍历了所有的样本，返回总额，所以并不是普通意义上轻量的&lt;code&gt;get&lt;/code&gt;方法，所以应该取名&lt;code&gt;computeMean&lt;/code&gt;比较合适。&lt;/p&gt;

&lt;h2&gt;漂亮的格式&lt;/h2&gt;

&lt;p&gt;写出来漂亮的格式，充满美感，读起来自然也会舒服很多，对比下面两个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class StatsKeeper {
   public:
   // A class for keeping track of a series of doubles
      void Add(double d);  // and methods for quick statistics about them
     private:   int count;        /* how many so    far
   */ public:
           double Average();
   private:   double minimum;
   list&amp;lt;double&amp;gt;
     past_items
         ;double maximum;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;什么是充满美感的呢：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A class for keeping track of a series of doubles
// and methods for quick statistics about them.
class StatsKeeper {
  public:
    void Add(double d);
    double Average();
  private:
    list&amp;lt;double&amp;gt; past_items;
    int count;  // how many so far
    double minimum;
    double maximum;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;考虑断行的连续性和简洁&lt;/h3&gt;

&lt;p&gt;这段代码需要断行，来满足不超过一行80个字符的要求，参数也需要注释说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class PerformanceTester {
    public static final TcpConnectionSimulator wifi = new TcpConnectionSimulator(
        500, /* Kbps */
        80, /* millisecs latency */
        200, /* jitter */
        1 /* packet loss % */);

    public static final TcpConnectionSimulator t3_fiber = new TcpConnectionSimulator(
        45000, /* Kbps */
        10, /* millisecs latency */
        0, /* jitter */
        0 /* packet loss % */);

    public static final TcpConnectionSimulator cell = new TcpConnectionSimulator(
        100, /* Kbps */
        400, /* millisecs latency */
        250, /* jitter */
        5 /* packet loss % */);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑到代码的连贯性，先优化成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class PerformanceTester {
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(
            500, /* Kbps */
            80, /* millisecs latency */ 200, /* jitter */
            1 /* packet loss % */);

    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(
            45000, /* Kbps */
            10,    /* millisecs latency */
            0,     /* jitter */
            0      /* packet loss % */);

    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(
            100,   /* Kbps */
            400,   /* millisecs latency */
            250,   /* jitter */
            5      /* packet loss % */);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连贯性好一点，但还是太罗嗦，额外占用很多空间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class PerformanceTester {
    // TcpConnectionSimulator(throughput, latency, jitter, packet_loss)
    //                            [Kbps]   [ms]    [ms]    [percent]
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(500,    80,     200,     1);

    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(45000,  10,     0,       0);

    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(100,    400,    250,     5);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;用函数封装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// Turn a partial_name like &quot;Doug Adams&quot; into &quot;Mr. Douglas Adams&quot;.
// If not possible, &#39;error&#39; is filled with an explanation.
string ExpandFullName(DatabaseConnection dc, string partial_name, string* error);

DatabaseConnection database_connection;
string error;
assert(ExpandFullName(database_connection, &quot;Doug Adams&quot;, &amp;amp;error)
        == &quot;Mr. Douglas Adams&quot;);
assert(error == &quot;&quot;);
assert(ExpandFullName(database_connection, &quot; Jake Brown &quot;, &amp;amp;error)
        == &quot;Mr. Jacob Brown III&quot;);
assert(error == &quot;&quot;);
assert(ExpandFullName(database_connection, &quot;No Such Guy&quot;, &amp;amp;error) == &quot;&quot;);
assert(error == &quot;no match found&quot;);
assert(ExpandFullName(database_connection, &quot;John&quot;, &amp;amp;error) == &quot;&quot;);
assert(error == &quot;more than one result&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码看起来很脏乱，很多重复性的东西，可以用函数封装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CheckFullName(&quot;Doug Adams&quot;, &quot;Mr. Douglas Adams&quot;, &quot;&quot;);
CheckFullName(&quot; Jake Brown &quot;, &quot;Mr. Jake Brown III&quot;, &quot;&quot;);
CheckFullName(&quot;No Such Guy&quot;, &quot;&quot;, &quot;no match found&quot;);
CheckFullName(&quot;John&quot;, &quot;&quot;, &quot;more than one result&quot;);

void CheckFullName(string partial_name,
                   string expected_full_name,
                   string expected_error) {
    // database_connection is now a class member
    string error;
    string full_name = ExpandFullName(database_connection, partial_name, &amp;amp;error);
    assert(error == expected_error);
    assert(full_name == expected_full_name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;列对齐&lt;/h3&gt;

&lt;p&gt;列对齐可以让代码段看起来更舒适：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CheckFullName(&quot;Doug Adams&quot;   , &quot;Mr. Douglas Adams&quot; , &quot;&quot;);
CheckFullName(&quot; Jake  Brown &quot;, &quot;Mr. Jake Brown III&quot;, &quot;&quot;);
CheckFullName(&quot;No Such Guy&quot;  , &quot;&quot;                  , &quot;no match found&quot;);
CheckFullName(&quot;John&quot;         , &quot;&quot;                  , &quot;more than one result&quot;);

commands[] = {
    ...
    { &quot;timeout&quot;      , NULL              , cmd_spec_timeout},
    { &quot;timestamping&quot; , &amp;amp;opt.timestamping , cmd_boolean},
    { &quot;tries&quot;        , &amp;amp;opt.ntry         , cmd_number_inf},
    { &quot;useproxy&quot;     , &amp;amp;opt.use_proxy    , cmd_boolean},
    { &quot;useragent&quot;    , NULL              , cmd_spec_useragent},
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;代码用块区分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class FrontendServer {
    public:
        FrontendServer();
        void ViewProfile(HttpRequest* request);
        void OpenDatabase(string location, string user);
        void SaveProfile(HttpRequest* request);
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void FindFriends(HttpRequest* request);
        void ReplyNotFound(HttpRequest* request, string error);
        void CloseDatabase(string location);
        ~FrontendServer();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这一段虽然能看，不过还有优化空间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class FrontendServer {
    public:
        FrontendServer();
        ~FrontendServer();
        // Handlers
        void ViewProfile(HttpRequest* request);
        void SaveProfile(HttpRequest* request);
        void FindFriends(HttpRequest* request);

        // Request/Reply Utilities
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void ReplyNotFound(HttpRequest* request, string error);

        // Database Helpers
        void OpenDatabase(string location, string user);
        void CloseDatabase(string location);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来看一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Import the user&#39;s email contacts, and match them to users in our system.
# Then display a list of those users that he/she isn&#39;t already friends with.
def suggest_new_friends(user, email_password):
    friends = user.friends()
    friend_emails = set(f.email for f in friends)
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)
    display[&#39;user&#39;] = user
    display[&#39;friends&#39;] = friends
    display[&#39;suggested_friends&#39;] = suggested_friends
    return render(&quot;suggested_friends.html&quot;, display)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全都混在一起，视觉压力相当大，按功能化块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def suggest_new_friends(user, email_password):
    # Get the user&#39;s friends&#39; email addresses.
    friends = user.friends()
    friend_emails = set(f.email for f in friends)

    # Import all email addresses from this user&#39;s email account.
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)

    # Find matching users that they aren&#39;t already friends with.
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)

    # Display these lists on the page. display[&#39;user&#39;] = user
    display[&#39;friends&#39;] = friends
    display[&#39;suggested_friends&#39;] = suggested_friends

    return render(&quot;suggested_friends.html&quot;, display)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让代码看起来更舒服，需要在写的过程中多注意，培养一些好的习惯，尤其当团队合作的时候，代码风格比如大括号的位置并没有对错，但是不遵循团队规范那就是错的。&lt;/p&gt;

&lt;h2&gt;如何写注释&lt;/h2&gt;

&lt;p&gt;当你写代码的时候，你会思考很多，但是最终呈现给读者的就只剩代码本身了，额外的信息丢失了，所以注释的目的就是让读者了解更多的信息。&lt;/p&gt;

&lt;h3&gt;应该注释什么&lt;/h3&gt;

&lt;h4&gt;不应该注释什么&lt;/h4&gt;

&lt;p&gt;这样的注释毫无价值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The class definition for Account
class Account {
    public:
        // Constructor
        Account();
        // Set the profit member to a new value
        void SetProfit(double profit);
        // Return the profit from this Account
        double GetProfit();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;不要像下面这样为了注释而注释：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Find a Node with the given &#39;name&#39; or return NULL.
// If depth &amp;lt;= 0, only &#39;subtree&#39; is inspected.
// If depth == N, only &#39;subtree&#39; and N levels below are inspected.
Node* FindNodeInSubtree(Node* subtree, string name, int depth);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;不要给烂取名注释&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Enforce limits on the Reply as stated in the Request,
// such as the number of items returned, or total byte size, etc. 
void CleanReply(Request request, Reply reply);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释的大部分都在解释clean是什么意思，那不如换个正确的名字：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Make sure &#39;reply&#39; meets the count/byte/etc. limits from the &#39;request&#39; 
void EnforceLimitsFromRequest(Request request, Reply reply);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;记录你的想法&lt;/h4&gt;

&lt;p&gt;我们讨论了不该注释什么，那么应该注释什么呢？注释应该记录你思考代码怎么写的结果，比如像下面这些：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Surprisingly, a binary tree was 40% faster than a hash table for this data.
// The cost of computing a hash was more than the left/right comparisons.

// This heuristic might miss a few words. That&#39;s OK; solving this 100% is hard.

// This class is getting messy. Maybe we should create a &#39;ResourceNode&#39; subclass to
// help organize things.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用来记录流程和常量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// TODO: use a faster algorithm
// TODO(dustin): handle other image formats besides JPEG

NUM_THREADS = 8 # as long as it&#39;s &amp;gt;= 2 * num_processors, that&#39;s good enough.

// Impose a reasonable limit - no human can read that much anyway.
const int MAX_RSS_SUBSCRIPTIONS = 1000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可用的词有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TODO  : Stuff I haven&#39;t gotten around to yet
FIXME : Known-broken code here
HACK  : Adimittedly inelegant solution to a problem
XXX   : Danger! Major problem here
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;站在读者的角度去思考&lt;/h4&gt;

&lt;p&gt;当别人读你的代码时，让他们产生疑问的部分，就是你应该注释的地方。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Recorder {
    vector&amp;lt;float&amp;gt; data;
    ...
    void Clear() {
        vector&amp;lt;float&amp;gt;().swap(data); // Huh? Why not just data.clear()? 
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多C++的程序员啊看到这里，可能会想为什么不用&lt;code&gt;data.clear()&lt;/code&gt;来代替&lt;code&gt;vector.swap&lt;/code&gt;，所以那个地方应该加上注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Force vector to relinquish its memory (look up &quot;STL swap trick&quot;)
vector&amp;lt;float&amp;gt;().swap(data);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;说明可能陷阱&lt;/h4&gt;

&lt;p&gt;你在写代码的过程中，可能用到一些hack，或者有其他需要读代码的人知道的陷阱，这时候就应该注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void SendEmail(string to, string subject, string body);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而实际上这个发送邮件的函数是调用别的服务，有超时设置，所以需要注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Calls an external service to deliver email.  (Times out after 1 minute.)
void SendEmail(string to, string subject, string body);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;全景的注释&lt;/h4&gt;

&lt;p&gt;有时候为了更清楚说明，需要给整个文件加注释，让读者有个总体的概念：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// This file contains helper functions that provide a more convenient interface to our
// file system. It handles file permissions and other nitty-gritty details.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;总结性的注释&lt;/h4&gt;

&lt;p&gt;即使是在函数内部，也可以有类似文件注释那样的说明注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Find all the items that customers purchased for themselves.
for customer_id in all_customers:
    for sale in all_sales[customer_id].sales:
        if sale.recipient == customer_id:
            ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者按照函数的步进，写一些注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def GenerateUserReport():
    # Acquire a lock for this user
    ...
    # Read user&#39;s info from the database
    ...
    # Write info to a file
    ...
    # Release the lock for this user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多人不愿意写注释，确实，要写好注释也不是一件简单的事情，也可以在文件专门的地方，留个写注释的区域，可以写下你任何想说的东西。&lt;/p&gt;

&lt;h3&gt;注释应简明准确&lt;/h3&gt;

&lt;p&gt;前一个小节讨论了注释应该写什么，这一节来讨论应该怎么写，因为注释很重要，所以要写的精确，注释也占据屏幕空间，所以要简洁。&lt;/p&gt;

&lt;h4&gt;精简注释&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// The int is the CategoryType.
// The first float in the inner pair is the &#39;score&#39;,
// the second is the &#39;weight&#39;.
typedef hash_map&amp;lt;int, pair&amp;lt;float, float&amp;gt; &amp;gt; ScoreMap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写太罗嗦了，尽量精简压缩成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// CategoryType -&amp;gt; (score, weight)
typedef hash_map&amp;lt;int, pair&amp;lt;float, float&amp;gt; &amp;gt; ScoreMap;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;避免有歧义的代词&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Insert the data into the cache, but check if it&#39;s too big first.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;it&#39;s&lt;/code&gt;有歧义，不知道所指的是&lt;code&gt;data&lt;/code&gt;还是&lt;code&gt;cache&lt;/code&gt;，改成如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Insert the data into the cache, but check if the data is too big first.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有更好的解决办法，这里的&lt;code&gt;it&lt;/code&gt;就有明确所指：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// If the data is small enough, insert it into the cache.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;语句要精简准确&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# Depending on whether we&#39;ve already crawled this URL before, give it a different priority.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句话理解起来太费劲，改成如下就好理解很多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Give higher priority to URLs we&#39;ve never crawled before.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;精确描述函数的目的&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Return the number of lines in this file.
int CountLines(string filename) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的一个函数，用起来可能会一头雾水，因为他可以有很多歧义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&quot;&quot; 一个空文件，是0行还是1行？&lt;/li&gt;
&lt;li&gt;&quot;hello&quot; 只有一行，那么返回值是0还是1？&lt;/li&gt;
&lt;li&gt;&quot;hello\n&quot; 这种情况返回1还是2？&lt;/li&gt;
&lt;li&gt;&quot;hello\n world&quot; 返回1还是2？&lt;/li&gt;
&lt;li&gt;&quot;hello\n\r cruel\n world\r&quot; 返回2、3、4哪一个呢？&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以注释应该这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Count how many newline bytes (&#39;\n&#39;) are in the file.
int CountLines(string filename) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;用实例说明边界情况&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Rearrange &#39;v&#39; so that elements &amp;lt; pivot come before those &amp;gt;= pivot;
// Then return the largest &#39;i&#39; for which v[i] &amp;lt; pivot (or -1 if none are &amp;lt; pivot)
int Partition(vector&amp;lt;int&amp;gt;* v, int pivot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个描述很精确，但是如果再加入一个例子，就更好了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
// Example: Partition([8 5 9 8 2], 8) might result in [5 2 | 8 9 8] and return 1
int Partition(vector&amp;lt;int&amp;gt;* v, int pivot);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;说明你的代码的真正目的&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;void DisplayProducts(list&amp;lt;Product&amp;gt; products) {
    products.sort(CompareProductByPrice);
    // Iterate through the list in reverse order
    for (list&amp;lt;Product&amp;gt;::reverse_iterator it = products.rbegin(); it != products.rend();
            ++it)
        DisplayPrice(it-&amp;gt;price);
    ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的注释说明了倒序排列，单还不够准确，应该改成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Display each price, from highest to lowest
for (list&amp;lt;Product&amp;gt;::reverse_iterator it = products.rbegin(); ... )
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;函数调用时的注释&lt;/h4&gt;

&lt;p&gt;看见这样的一个函数调用，肯定会一头雾水：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connect(10, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果加上这样的注释，读起来就清楚多了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def Connect(timeout, use_encryption):  ...

# Call the function using named parameters
Connect(timeout = 10, use_encryption = False)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;使用信息含量丰富的词&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// This class contains a number of members that store the same information as in the
// database, but are stored here for speed. When this class is read from later, those
// members are checked first to see if they exist, and if so are returned; otherwise the
// database is read from and that data stored in those fields for next time.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这一大段注释，解释的很清楚，如果换一个词来代替，也不会有什么疑惑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// This class acts as a caching layer to the database.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;简化循环和逻辑&lt;/h2&gt;

&lt;h3&gt;流程控制要简单&lt;/h3&gt;

&lt;p&gt;让条件语句、循环以及其他控制流程的代码尽可能自然，让读者在阅读过程中不需要停顿思考或者在回头查找，是这一节的目的。&lt;/p&gt;

&lt;h4&gt;条件语句中参数的位置&lt;/h4&gt;

&lt;p&gt;对比下面两种条件的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (length &amp;gt;= 10)
while (bytes_received &amp;lt; bytes_expected)

if (10 &amp;lt;= length)
while (bytes_expected &amp;gt; bytes_received)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到底是应该按照大于小于的顺序来呢，还是有其他的准则？是的，应该按照参数的意义来&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;运算符左边：通常是需要被检查的变量，也就是会经常变化的&lt;/li&gt;
&lt;li&gt;运算符右边：通常是被比对的样本，一定程度上的常量&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这就解释了为什么&lt;code&gt;bytes_received &amp;lt; bytes_expected&lt;/code&gt;比反过来更好理解。&lt;/p&gt;

&lt;h4&gt;if/else的顺序&lt;/h4&gt;

&lt;p&gt;通常，&lt;code&gt;if/else&lt;/code&gt;的顺序你可以自由选择，下面这两种都可以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (a == b) {
    // Case One ...
} else {
    // Case Two ...
}

if (a != b) {
    // Case Two ...
} else {
    // Case One ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或许对此你也没有仔细斟酌过，但在有些时候，一种顺序确实好过另一种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正向的逻辑在前，比如&lt;code&gt;if(debug)&lt;/code&gt;就比&lt;code&gt;if(!debug)&lt;/code&gt;好&lt;/li&gt;
&lt;li&gt;简单逻辑的在前，这样&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;else&lt;/code&gt;就可以在一个屏幕显示&lt;/li&gt;
&lt;li&gt;有趣、清晰的逻辑在前&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;举个例子来看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!url.HasQueryParameter(&quot;expand_all&quot;)) {
    response.Render(items);
    ...
} else {
    for (int i = 0; i &amp;lt; items.size(); i++) {
        items[i].Expand();
    }
    ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到&lt;code&gt;if&lt;/code&gt;你首先想到的是&lt;code&gt;expand_all&lt;/code&gt;，就好像告诉你“不要想大象”，你会忍不住去想它，所以产生了一点点迷惑，最好写成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (url.HasQueryParameter(&quot;expand_all&quot;)) {
    for (int i = 0; i &amp;lt; items.size(); i++) {
        items[i].Expand();
    }
    ... 
} else {
    response.Render(items);
    ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;三目运算符(?:)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;time_str += (hour &amp;gt;= 12) ? &quot;pm&quot; : &quot;am&quot;;

Avoiding the ternary operator, you might write:
    if (hour &amp;gt;= 12) {
        time_str += &quot;pm&quot;;
    } else {
        time_str += &quot;am&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用三目运算符可以减少代码行数，上例就是一个很好的例证，但是我们的真正目的是减少读代码的时间，所以下面的情况并不适合用三目运算符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return exponent &amp;gt;= 0 ? mantissa * (1 &amp;lt;&amp;lt; exponent) : mantissa / (1 &amp;lt;&amp;lt; -exponent);

if (exponent &amp;gt;= 0) {
    return mantissa * (1 &amp;lt;&amp;lt; exponent);
} else {
    return mantissa / (1 &amp;lt;&amp;lt; -exponent);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以只在简单表达式的地方用。&lt;/p&gt;

&lt;h4&gt;避免使用do/while表达式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;do {
    continue;
} while (false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码会执行几遍呢，需要时间思考一下，&lt;code&gt;do/while&lt;/code&gt;完全可以用别的方法代替，所以应避免使用。&lt;/p&gt;

&lt;h4&gt;尽早return&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public boolean Contains(String str, String substr) {
    if (str == null || substr == null) return false;
    if (substr.equals(&quot;&quot;)) return true;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数里面尽早的return，可以让逻辑更加清晰。&lt;/p&gt;

&lt;h4&gt;减少嵌套&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;if (user_result == SUCCESS) {
    if (permission_result != SUCCESS) {
        reply.WriteErrors(&quot;error reading permissions&quot;);
        reply.Done();
        return;
    }
    reply.WriteErrors(&quot;&quot;);
} else {
    reply.WriteErrors(user_result);
}
reply.Done();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一段代码，有一层的嵌套，但是看起来也会稍有迷惑，想想自己的代码，有没有类似的情况呢？可以换个思路去考虑这段代码，并且用尽早return的原则修改，看起来就舒服很多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (user_result != SUCCESS) {
    reply.WriteErrors(user_result);
    reply.Done();
    return;
}
if (permission_result != SUCCESS) {
    reply.WriteErrors(permission_result);
    reply.Done();
    return;
}
reply.WriteErrors(&quot;&quot;);
reply.Done();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的，对于有嵌套的循环，可以采用同样的办法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; results.size(); i++) {
    if (results[i] != NULL) {
        non_null_count++;
        if (results[i]-&amp;gt;name != &quot;&quot;) {
            cout &amp;lt;&amp;lt; &quot;Considering candidate...&quot; &amp;lt;&amp;lt; endl;
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换一种写法，尽早return，在循环中就用continue：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; results.size(); i++) {
    if (results[i] == NULL) continue;
    non_null_count++;

    if (results[i]-&amp;gt;name == &quot;&quot;) continue;
    cout &amp;lt;&amp;lt; &quot;Considering candidate...&quot; &amp;lt;&amp;lt; endl;
    ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;拆分复杂表达式&lt;/h3&gt;

&lt;p&gt;很显然的，越复杂的表达式，读起来越费劲，所以应该把那些复杂而庞大的表达式，拆分成一个个易于理解的小式子。&lt;/p&gt;

&lt;h4&gt;用变量&lt;/h4&gt;

&lt;p&gt;将复杂表达式拆分最简单的办法，就是增加一个变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if line.split(&#39;:&#39;)[0].strip() == &quot;root&quot;:

//用变量替换
username = line.split(&#39;:&#39;)[0].strip() 
if username == &quot;root&quot;:
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (request.user.id == document.owner_id) {
    // user can edit this document...
}
...
if (request.user.id != document.owner_id) {
// document is read-only...
}

//用变量替换
final boolean user_owns_document = (request.user.id == document.owner_id);
if (user_owns_document) {
    // user can edit this document...
}
...
if (!user_owns_document) {
    // document is read-only...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;逻辑替换&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;1) not (a or b or c)   &lt;--&gt; (not a) and (not b) and (not c)&lt;/li&gt;
&lt;li&gt;2) not (a and b and c) &lt;--&gt; (not a) or (not b) or (not c)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以，就可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!(file_exists &amp;amp;&amp;amp; !is_protected)) Error(&quot;Sorry, could not read file.&quot;);

//替换
if (!file_exists || is_protected) Error(&quot;Sorry, could not read file.&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;不要滥用逻辑表达式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;assert((!(bucket = FindBucket(key))) || !bucket-&amp;gt;IsOccupied());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的代码完全可以用下面这个替换，虽然有两行，但是更易懂：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bucket = FindBucket(key);
if (bucket != NULL) assert(!bucket-&amp;gt;IsOccupied());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像下面这样的表达式，最好也不要写，因为在有些语言中，x会被赋予第一个为&lt;code&gt;true&lt;/code&gt;的变量的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = a || b || c
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;拆解大表达式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var update_highlight = function (message_num) {
    if ($(&quot;#vote_value&quot; + message_num).html() === &quot;Up&quot;) {
        $(&quot;#thumbs_up&quot; + message_num).addClass(&quot;highlighted&quot;);
        $(&quot;#thumbs_down&quot; + message_num).removeClass(&quot;highlighted&quot;);
    } else if ($(&quot;#vote_value&quot; + message_num).html() === &quot;Down&quot;) {
        $(&quot;#thumbs_up&quot; + message_num).removeClass(&quot;highlighted&quot;);
        $(&quot;#thumbs_down&quot; + message_num).addClass(&quot;highlighted&quot;);
    } else {
        $(&quot;#thumbs_up&quot; + message_num).removeClass(&quot;highighted&quot;);
        $(&quot;#thumbs_down&quot; + message_num).removeClass(&quot;highlighted&quot;);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面有很多重复的语句，我们可以用变量还替换简化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var update_highlight = function (message_num) {
    var thumbs_up = $(&quot;#thumbs_up&quot; + message_num);
    var thumbs_down = $(&quot;#thumbs_down&quot; + message_num);
    var vote_value = $(&quot;#vote_value&quot; + message_num).html();
    var hi = &quot;highlighted&quot;;

    if (vote_value === &quot;Up&quot;) {
        thumbs_up.addClass(hi);
        thumbs_down.removeClass(hi);
    } else if (vote_value === &quot;Down&quot;) {
        thumbs_up.removeClass(hi);
        thumbs_down.addClass(hi);
    } else {
        thumbs_up.removeClass(hi);
        thumbs_down.removeClass(hi);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;变量与可读性&lt;/h3&gt;

&lt;h4&gt;消除变量&lt;/h4&gt;

&lt;p&gt;前一节，讲到利用变量来拆解大表达式，这一节来讨论如何消除多余的变量。&lt;/p&gt;

&lt;h4&gt;没用的临时变量&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;now = datetime.datetime.now()
root_message.last_view_time = now
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;now&lt;/code&gt;可以去掉，因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;并非用来拆分复杂的表达式&lt;/li&gt;
&lt;li&gt;也没有增加可读性，因为`datetime.datetime.now()`本就清晰&lt;/li&gt;
&lt;li&gt;只用了一次&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以完全可以写作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root_message.last_view_time = datetime.datetime.now()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;消除条件控制变量&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;boolean done = false;
while (/* condition */ &amp;amp;&amp;amp; !done) {
    ...
    if (...) {
        done = true;
        continue; 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;done&lt;/code&gt;可以用别的方式更好的完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (/* condition */) {
    ...
    if (...) {
        break;
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子非常容易修改，如果是比较复杂的嵌套，&lt;code&gt;break&lt;/code&gt;可能并不够用，这时候就可以把代码封装到函数中。&lt;/p&gt;

&lt;h4&gt;减少变量的作用域&lt;/h4&gt;

&lt;p&gt;我们都听过要避免使用全局变量这样的忠告，是的，当变量的作用域越大，就越难追踪，所以要保持变量小的作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class LargeClass {
    string str_;
    void Method1() {
        str_ = ...;
        Method2();
    }
    void Method2() {
        // Uses str_
    }
    // Lots of other methods that don&#39;t use str_ 
    ... ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;str_&lt;/code&gt;的作用域有些大，完全可以换一种方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class LargeClass {
    void Method1() {
        string str = ...;
        Method2(str); 
    }
    void Method2(string str) {
        // Uses str
    }
    // Now other methods can&#39;t see str.
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将&lt;code&gt;str&lt;/code&gt;通过变量函数参数传递，减小了作用域，也更易读。同样的道理也可以用在定义类的时候，将大类拆分成一个个小类。&lt;/p&gt;

&lt;h4&gt;不要使用嵌套的作用域&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# No use of example_value up to this point.
if request:
    for value in request.values:
    if value &amp;gt; 0:
        example_value = value 
        break

for logger in debug.loggers:
    logger.log(&quot;Example:&quot;, example_value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子在运行时候会报&lt;code&gt;example_value is undefined&lt;/code&gt;的错，修改起来不算难：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;example_value = None
if request:
    for value in request.values:
        if value &amp;gt; 0: example_value = value 
        break

if example_value:
    for logger in debug.loggers:
    logger.log(&quot;Example:&quot;, example_value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是参考前面的&lt;strong&gt;消除中间变量&lt;/strong&gt;准则，还有更好的办法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def LogExample(value):
    for logger in debug.loggers:
        logger.log(&quot;Example:&quot;, value)

    if request:
        for value in request.values:
            if value &amp;gt; 0:
                LogExample(value)  # deal with &#39;value&#39; immediately
                break
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;用到了再声明&lt;/h4&gt;

&lt;p&gt;在C语言中，要求将所有的变量事先声明，这样当用到变量较多时候，读者处理这些信息就会有难度，所以一开始没用到的变量，就暂缓声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def ViewFilteredReplies(original_id):
    filtered_replies = []
    root_message = Messages.objects.get(original_id) 
    all_replies = Messages.objects.select(root_id=original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    for reply in all_replies:
        if reply.spam_votes &amp;lt;= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读者一次处理变量太多，可以暂缓声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def ViewFilteredReplies(original_id):
    root_message = Messages.objects.get(original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    all_replies = Messages.objects.select(root_id=original_id) 
    filtered_replies = []
    for reply in all_replies:
        if reply.spam_votes &amp;lt;= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;变量最好只写一次&lt;/h4&gt;

&lt;p&gt;前面讨论了过多的变量会让读者迷惑，同一个变量，不停的被赋值也会让读者头晕，如果变量变化的次数少一些，代码可读性就更强。&lt;/p&gt;

&lt;h4&gt;一个例子&lt;/h4&gt;

&lt;p&gt;假设有一个页面，如下，需要给第一个空的&lt;code&gt;input&lt;/code&gt;赋值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&quot;text&quot; id=&quot;input1&quot; value=&quot;Dustin&quot;&amp;gt;
&amp;lt;input type=&quot;text&quot; id=&quot;input2&quot; value=&quot;Trevor&quot;&amp;gt;
&amp;lt;input type=&quot;text&quot; id=&quot;input3&quot; value=&quot;&quot;&amp;gt;
&amp;lt;input type=&quot;text&quot; id=&quot;input4&quot; value=&quot;Melissa&quot;&amp;gt;
...
var setFirstEmptyInput = function (new_value) {
    var found = false;
    var i = 1;
    var elem = document.getElementById(&#39;input&#39; + i);
    while (elem !== null) {
        if (elem.value === &#39;&#39;) {
            found = true;
            break; 
        }
        i++;
        elem = document.getElementById(&#39;input&#39; + i);
    }
    if (found) elem.value = new_value;
    return elem;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码能工作，有三个变量，我们逐一去看如何优化，&lt;code&gt;found&lt;/code&gt;作为中间变量，完全可以消除：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var setFirstEmptyInput = function (new_value) {
    var i = 1;
    var elem = document.getElementById(&#39;input&#39; + i);
    while (elem !== null) {
        if (elem.value === &#39;&#39;) {
            elem.value = new_value;
            return elem;
        }
        i++;
        elem = document.getElementById(&#39;input&#39; + i);
    }
    return null;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来看&lt;code&gt;elem&lt;/code&gt;变量，只用来做循环，调用了很多次，所以很难跟踪他的值，&lt;code&gt;i&lt;/code&gt;也可以用&lt;code&gt;for&lt;/code&gt;来修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var setFirstEmptyInput = function (new_value) {
    for (var i = 1; true; i++) {
        var elem = document.getElementById(&#39;input&#39; + i);
        if (elem === null)
            return null;  // Search Failed. No empty input found.
        if (elem.value === &#39;&#39;) {
            elem.value = new_value;
            return elem;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;重新组织你的代码&lt;/h2&gt;

&lt;h3&gt;分离不相关的子问题&lt;/h3&gt;

&lt;p&gt;工程师就是将大问题分解为一个个小问题，然后逐个解决，这样也易于保证程序的健壮性、可读性。如何分解子问题，下面给出一些准则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;看看这个方法或代码，问问你自己“这段代码的最终目标是什么？”&lt;/li&gt;
&lt;li&gt;对于每一行代码，要问“它与目标直接相关，或者是不相关的子问题？”&lt;/li&gt;
&lt;li&gt;如果有足够多行的代码是处理与目标不直接相关的问题，那么抽离成子函数&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;来看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ajax_post({
    url: &#39;http://example.com/submit&#39;,
    data: data,
    on_success: function (response_data) {
        var str = &quot;{\n&quot;;
        for (var key in response_data) {
            str += &quot;  &quot; + key + &quot; = &quot; + response_data[key] + &quot;\n&quot;;
        }
        alert(str + &quot;}&quot;);
        // Continue handling &#39;response_data&#39; ...
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的目标是发送一个&lt;code&gt;ajax&lt;/code&gt;请求，所以其中字符串处理的部分就可以抽离出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var format_pretty = function (obj) {
    var str = &quot;{\n&quot;;
    for (var key in obj) {
        str += &quot;  &quot; + key + &quot; = &quot; + obj[key] + &quot;\n&quot;;
    }
    return str + &quot;}&quot;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;意外收获&lt;/h4&gt;

&lt;p&gt;有很多理由将&lt;code&gt;format_pretty&lt;/code&gt;抽离出来，这些独立的函数可以很容易的添加feature，增强可靠性，处理边界情况，等等。所以这里，可以将&lt;code&gt;format_pretty&lt;/code&gt;增强，就会得到一个更强大的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var format_pretty = function (obj, indent) {
    // Handle null, undefined, strings, and non-objects.
    if (obj === null) return &quot;null&quot;;
    if (obj === undefined) return &quot;undefined&quot;;
    if (typeof obj === &quot;string&quot;) return &#39;&quot;&#39; + obj + &#39;&quot;&#39;;
    if (typeof obj !== &quot;object&quot;) return String(obj);
    if (indent === undefined) indent = &quot;&quot;;

    // Handle (non-null) objects.

    var str = &quot;{\n&quot;;
    for (var key in obj) {
        str += indent + &quot;  &quot; + key + &quot; = &quot;;
        str += format_pretty(obj[key], indent + &quot; &quot;) + &quot;\n&quot;; }
    return str + indent + &quot;}&quot;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    key1 = 1
    key2 = true
    key3 = undefined
    key4 = null
    key5 = {
        key5a = {
            key5a1 = &quot;hello world&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多做这样的事情，就是积累代码的过程，这样的代码可以复用，也可以形成自己的代码库，或者分享给别人。&lt;/p&gt;

&lt;h4&gt;业务相关的函数&lt;/h4&gt;

&lt;p&gt;那些与目标不相关函数，抽离出来可以复用，与业务相关的也可以抽出来，保持代码的易读性，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;business = Business()
business.name = request.POST[&quot;name&quot;]

url_path_name = business.name.lower()
url_path_name = re.sub(r&quot;[&#39;\.]&quot;, &quot;&quot;, url_path_name) 
url_path_name = re.sub(r&quot;[^a-z0-9]+&quot;, &quot;-&quot;, url_path_name) 
url_path_name = url_path_name.strip(&quot;-&quot;)
business.url = &quot;/biz/&quot; + url_path_name

business.date_created = datetime.datetime.utcnow() 
business.save_to_database()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抽离出来，就好看很多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CHARS_TO_REMOVE = re.compile(r&quot;[&#39;\.&#39;]+&quot;)
CHARS_TO_DASH = re.compile(r&quot;[^a-z0-9]+&quot;)

def make_url_friendly(text):
    text = text.lower()
    text = CHARS_TO_REMOVE.sub(&#39;&#39;, text) 
    text = CHARS_TO_DASH.sub(&#39;-&#39;, text) 
    return text.strip(&quot;-&quot;)

business = Business()
business.name = request.POST[&quot;name&quot;]
business.url = &quot;/biz/&quot; + make_url_friendly(business.name) 
business.date_created = datetime.datetime.utcnow() 
business.save_to_database()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;简化现有接口&lt;/h4&gt;

&lt;p&gt;我们来看一个读写cookie的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var max_results;
var cookies = document.cookie.split(&#39;;&#39;);
for (var i = 0; i &amp;lt; cookies.length; i++) {
    var c = cookies[i];
    c = c.replace(/^[ ]+/, &#39;&#39;);  // remove leading spaces
    if (c.indexOf(&quot;max_results=&quot;) === 0)
        max_results = Number(c.substring(12, c.length));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码实在太丑了，理想的接口应该是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set_cookie(name, value, days_to_expire);
delete_cookie(name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于并不理想的接口，你永远可以用自己的函数做封装，让接口更好用。&lt;/p&gt;

&lt;h4&gt;按自己需要写接口&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;ser_info = { &quot;username&quot;: &quot;...&quot;, &quot;password&quot;: &quot;...&quot; }
user_str = json.dumps(user_info)
cipher = Cipher(&quot;aes_128_cbc&quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE)
encrypted_bytes = cipher.update(user_str)
encrypted_bytes += cipher.final() # flush out the current 128 bit block
url = &quot;http://example.com/?user_info=&quot; + base64.urlsafe_b64encode(encrypted_bytes)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然终极目的是拼接用户信息的字符，但是代码大部分做的事情是解析python的object，所以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def url_safe_encrypt(obj):
    obj_str = json.dumps(obj)
    cipher = Cipher(&quot;aes_128_cbc&quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE) encrypted_bytes = cipher.update(obj_str)
    encrypted_bytes += cipher.final() # flush out the current 128 bit block
    return base64.urlsafe_b64encode(encrypted_bytes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在其他地方也可以调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user_info = { &quot;username&quot;: &quot;...&quot;, &quot;password&quot;: &quot;...&quot; }
url = &quot;http://example.com/?user_info=&quot; + url_safe_encrypt(user_info)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分离子函数是好习惯，但是也要适度，过度的分离成多个小函数，也会让查找变得困难。&lt;/p&gt;

&lt;h3&gt;单任务&lt;/h3&gt;

&lt;p&gt;代码应该是一次只完成一个任务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var place = location_info[&quot;LocalityName&quot;];  // e.g. &quot;Santa Monica&quot;
if (!place) {
    place = location_info[&quot;SubAdministrativeAreaName&quot;];  // e.g. &quot;Los Angeles&quot;
}
if (!place) {
    place = location_info[&quot;AdministrativeAreaName&quot;];  // e.g. &quot;California&quot;
}
if (!place) {
    place = &quot;Middle-of-Nowhere&quot;;
}
if (location_info[&quot;CountryName&quot;]) {
    place += &quot;, &quot; + location_info[&quot;CountryName&quot;];  // e.g. &quot;USA&quot;
} else {
    place += &quot;, Planet Earth&quot;;
}

return place;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个用来拼地名的函数，有很多的条件判断，读起来非常吃力，有没有办法拆解任务呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var town    = location_info[&quot;LocalityName&quot;];               // e.g. &quot;Santa Monica&quot;
var city    = location_info[&quot;SubAdministrativeAreaName&quot;];  // e.g. &quot;Los Angeles&quot;
var state   = location_info[&quot;AdministrativeAreaName&quot;];     // e.g. &quot;CA&quot;
var country = location_info[&quot;CountryName&quot;];                // e.g. &quot;USA&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先拆解第一个任务，将各变量分别保存，这样在后面使用中不需要去记忆那些繁长的key值了，第二个任务，解决地址拼接的后半部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Start with the default, and keep overwriting with the most specific value. var second_half = &quot;Planet Earth&quot;;
if (country) {
    second_half = country; 
}
if (state &amp;amp;&amp;amp; country === &quot;USA&quot;) {
    second_half = state; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来解决前半部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var first_half = &quot;Middle-of-Nowhere&quot;;
if (state &amp;amp;&amp;amp; country !== &quot;USA&quot;) {
    first_half = state; 
}
if (city) {
    first_half = city;
}
if (town) {
    first_half = town; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大功告成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return first_half + &quot;, &quot; + second_half;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果注意到有&lt;code&gt;USA&lt;/code&gt;这个变量的判断的话，也可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var first_half, second_half;
if (country === &quot;USA&quot;) {
    first_half = town || city || &quot;Middle-of-Nowhere&quot;;
    second_half = state || &quot;USA&quot;;
} else {
    first_half = town || city || state || &quot;Middle-of-Nowhere&quot;;
    second_half = country || &quot;Planet Earth&quot;;
}
return first_half + &quot;, &quot; + second_half;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;把想法转换成代码&lt;/h3&gt;

&lt;p&gt;要把一个复杂的东西解释给别人，一些细节很容易就让人产生迷惑，所以想象把你的代码用平实的语言解释给别人听，别人是否能懂，有一些准则可以帮助你让代码更清晰：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用最平实的语言描述代码的目的，就像给读者讲述一样&lt;/li&gt;
&lt;li&gt;注意描述中关键的字词&lt;/li&gt;
&lt;li&gt;让你的代码符合你的描述&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下面这段代码用来校验用户的权限：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$is_admin = is_admin_request();
if ($document) {
    if (!$is_admin &amp;amp;&amp;amp; ($document[&#39;username&#39;] != $_SESSION[&#39;username&#39;])) {
        return not_authorized();
    }
} else {
    if (!$is_admin) {
        return not_authorized();
    } 
}
// continue rendering the page ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一段代码不长，里面的逻辑嵌套倒是复杂，参考前面章节所述，嵌套太多非常影响阅读理解，将这个逻辑用语言描述就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;有两种情况有权限：
1、你是管理员(admin)
2、你拥有这个文档
否则就没有权限
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据描述来写代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (is_admin_request()) {
    // authorized
} elseif ($document &amp;amp;&amp;amp; ($document[&#39;username&#39;] == $_SESSION[&#39;username&#39;])) {
    // authorized
} else {
    return not_authorized();
}
// continue rendering the page ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;写更少的代码&lt;/h3&gt;

&lt;p&gt;最易懂的代码就是没有代码！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;去掉那些没意义的feature，也不要过度设计&lt;/li&gt;
&lt;li&gt;重新考虑需求，解决最简单的问题，也能完成整体的目标&lt;/li&gt;
&lt;li&gt;熟悉你常用的库，周期性研究他的API&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;最后&lt;/h2&gt;

&lt;p&gt;还有一些与测试相关的章节，留给你自己去研读吧，再次推荐此书：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;英文版：&lt;a href=&quot;http://book.douban.com/subject/5442971/&quot; title=&quot;The Art Of Readable Code&quot;&gt;《The Art of Readable Code》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文版：&lt;a href=&quot;http://book.douban.com/subject/10797189/&quot; title=&quot;编写可读代码的艺术&quot;&gt;编写可读代码的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>随内容滚动隐藏的工具栏</title>
     <link href="http://blog.11010.net/auto-edit-bar"/>
     <updated>2012-12-27T00:00:00+08:00</updated>
     <id>http://beiyuu.com/auto-edit-bar</id>
     <content type="html">&lt;p&gt;最先在&lt;a href=&quot;https://itunes.apple.com/us/app/google+/id447119634?mt=8&quot;&gt;Google+&lt;/a&gt;的APP上看到这种交互细节，而后在&lt;a href=&quot;http://www.meilishuo.com/welcome&quot;&gt;美丽说&lt;/a&gt;的新版上也看到了，上图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/other/auto-edit-bar.jpg&quot; alt=&quot;Auto Edit Bar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中画蓝色线框的部分既是。打开APP，下面的工具栏部分是显示的，当手指滑动内容，如果是向下浏览更多内容，工具栏自动收起，如果向上回滚，工具栏又会显示。&lt;/p&gt;

&lt;p&gt;好处显而易见，当APP认为你在浏览，收起留出更多的屏幕空间，不遮挡、影响内容的显示，需要时再出现。&lt;/p&gt;

&lt;p&gt;起初看到这个交互，还有些不习惯，体会到他的优势之后，顿时又觉得不支持这样的APP实在太out。&lt;/p&gt;

&lt;p&gt;Google+和美丽说还有些不同的细节：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Google+是在手指动作触发刚开始时就起效，而美丽说做在了手指滑动之后，因为有个缓冲时间，所以略感迟钝。&lt;/li&gt;
    &lt;li&gt;美丽说在工具栏收起之后，留有一个小按钮，其实当用户熟悉这个交互后，略显多余。&lt;/li&gt;
&lt;/ul&gt;



</content>
   </entry>
   
   <entry>
     <title>如果侧滑成为APP标配</title>
     <link href="http://blog.11010.net/side-slide"/>
     <updated>2012-12-26T00:00:00+08:00</updated>
     <id>http://beiyuu.com/side-slide</id>
     <content type="html">&lt;p&gt;前两天这样感叹过：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;
像Weico和网易新闻的手势滑动后退这样流畅、高效的交互真让人爱不释手，而且会很快形成惯性，真期待成为各App标配。就像当年第一次用完触屏手机，再去用其他机器，都会上手去摸一样。
&lt;/p&gt;&lt;/blockquote&gt;


&lt;p&gt;&lt;img src=&quot;/images/other/side-slide.jpg&quot; alt=&quot;Weico Side&quot; /&gt;&lt;/p&gt;

&lt;p&gt;左图Weico的侧拉导航这种交互，从Path之后就遍地开花。对于手机应用，合理利用边缘操作，方便的隐藏显示功能，实在优雅。&lt;/p&gt;

&lt;p&gt;导航部分的侧拉交互并不是每个APP都需要，但是像右图中网易新闻的内容侧拉后退，我觉得应该成为各APP标配。&lt;/p&gt;

&lt;p&gt;这个交互并不新鲜，iPad上的&lt;a href=&quot;http://reederapp.com/ipad/&quot;&gt;Reeder&lt;/a&gt;和&lt;a href=&quot;http://alienblue.org/&quot;&gt;Alien Blue&lt;/a&gt;一直都有，iPad屏幕大，点击顶部按钮的动作幅度太大，问题很突出，就有了侧滑后退这个不错的办法。Alien Blue还像Mac下Finder的并列布局那样，会留有一定宽度的上级内容边缘，转换更加方便。&lt;/p&gt;

&lt;p&gt;先不说手机屏幕越来越大，这个交互本就是令人愉悦的，就像之前Tweetie的下拉刷新一样。人在习惯了高效的东西之后，就很难再回去了，我现在遇见不能侧滑后退的应用，心底的鄙视之情油然而生。可喜的是，很多应用也有了这个Feature，比如&lt;a href=&quot;http://instagram.com/&quot;&gt;Instagram&lt;/a&gt;，等等。&lt;/p&gt;

&lt;p&gt;侧滑本就是手机上很舒适自然的一个体验，想想你会不会没事解锁手机，桌面划两下，再锁屏呢？&lt;/p&gt;

&lt;p&gt;希望能有更多的PM、设计师和开发者认同，赶紧给自己的APP加上这个舒适的Feature吧！&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Git时代的VIM不完全使用教程</title>
     <link href="http://blog.11010.net/git-vim-tutorial"/>
     <updated>2012-11-27T00:00:00+08:00</updated>
     <id>http://beiyuu.com/git-vim-tutorial</id>
     <content type="html">&lt;p&gt;最近整理了VIM的配置，换上插件管理的神器-----&lt;a href=&quot;https://github.com/gmarik/vundle&quot;&gt;Vundle&lt;/a&gt;，由他引发的VIM生态环境的改善，堪称完美。遂打算写一份简单的教程，分享Git时代VIM新世界的美丽动人之处。&lt;strong&gt;对VIM有基础的同学，可直接跳至插件管理部分。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;VIM的模式&lt;/h2&gt;

&lt;p&gt;第一次使用VIM，会觉得无所适从，他并不像记事本，你敲什么键就显示什么，理解VIM的需要明白他的两种模式：
- 命令模式 (Command Mode)
- 编辑模式 (Insert Mode)&lt;/p&gt;

&lt;p&gt;命令模式下，可以做移动、编辑操作；编辑模式则用来输入。键入&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;o&lt;/code&gt;,&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;a&lt;/code&gt;等即可进入编辑模式，后面解释原因。&lt;/p&gt;

&lt;p&gt;模式的设计是VIM和其他编辑器最不同的地方，优势和劣势也全基于此而生。&lt;/p&gt;

&lt;h2&gt;基本操作&lt;/h2&gt;

&lt;p&gt;以下介绍的键盘操作，都是大小写敏感的，并且要在&lt;strong&gt;命令模式&lt;/strong&gt;下完成，需注意：&lt;/p&gt;

&lt;h3&gt;以字为单位的移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt; 向左移动一个字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j&lt;/code&gt; 向下移动一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt; 向上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt; 向右&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这四个键在右手最容易碰到几个位置，最为常用。&lt;/p&gt;

&lt;h3&gt;以词为单位的移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 下一個word w(ord)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt; 下一個word(跳过标点)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 前一個word b(ackward)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 前一个word(跳过标点)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e&lt;/code&gt; 跳到当前word的尾端 e(nd)&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;行移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 跳到当前行的开头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 跳到当前行第一个非空字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; 跳到行尾&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;助记：0(第0个字符),&lt;code&gt;^&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;含义同正则表达式&lt;/p&gt;

&lt;h3&gt;段落移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{&lt;/code&gt; 上一段(以空白行分隔)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;}&lt;/code&gt; 下一段(以空白行分隔)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt; 跳到当前对应的括号上(适用各种配对符号)&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;跳跃移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/xxxx&lt;/code&gt; 搜索xxxx，然后可以用&lt;code&gt;n&lt;/code&gt;下一个，&lt;code&gt;N&lt;/code&gt;上一个移动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 向前搜索光标当前所在的字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 向后搜索光标当前所在的字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fx&lt;/code&gt; 在当前行移动到光标之后第一个字符x的位置 f(ind)x&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gd&lt;/code&gt; 跳到光标所在位置词(word)的定义位置 g(o)d(efine)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gg&lt;/code&gt; 到文档顶部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt; 到文档底部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:x&lt;/code&gt; 跳到第x行(x是行号)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+d&lt;/code&gt; 向下翻页 d(down)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+u&lt;/code&gt; 向上翻页 u(p)&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;基本编辑&lt;/h3&gt;

&lt;h4&gt;修改&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 在光标当前位置向前插入 i(nsert)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; 在本行第一个字符前插入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 在光标当前位置向后插入 a(fter)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 在本行末尾插入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; 向下插入一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O&lt;/code&gt; 向上插入一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:w&lt;/code&gt; 保存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:q&lt;/code&gt; 退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:wq&lt;/code&gt; 保存并退出&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;删除&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 删除当前字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dd&lt;/code&gt; 删除当前行 d(elete)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dw&lt;/code&gt; 删除当前光标下的词 d(elete)w(ord)&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;复制粘贴&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yy&lt;/code&gt; 复制当前行 y(ank)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yw&lt;/code&gt; 复制当前光标下的词 y(ank)w(ord)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 粘贴 p(aste)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P&lt;/code&gt; 粘贴在当前位置之前&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;进阶操作&lt;/h2&gt;

&lt;p&gt;限于篇幅，在这里我仅介绍下我非常常用的几个操作。&lt;/p&gt;

&lt;h3&gt;重复操作&lt;/h3&gt;

&lt;p&gt;因为VIM所有的操作都是原子化的，所以把这些操作程序化就非常简单了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;5w&lt;/code&gt; 相当于按五次&lt;code&gt;w&lt;/code&gt;键；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;6j&lt;/code&gt; 下移6行，相当于按六次j；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3J&lt;/code&gt; 大写J,本来是将下一行与当前行合并，加上数量，就是重复操作3次；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;6dw&lt;/code&gt;和&lt;code&gt;d6w&lt;/code&gt; 结果是一样，就是删除6个word；&lt;/li&gt;
&lt;li&gt;剩下的无数情况，自己类推吧。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;高效编辑&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;di&quot;&lt;/code&gt; 光标在&quot;&quot;之间，则删除&quot;&quot;之间的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yi(&lt;/code&gt; 光标在()之间，则复制()之间的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vi[&lt;/code&gt; 光标在[]之间，则选中[]之间的内容&lt;/li&gt;
&lt;li&gt;以上三种可以自由组合搭配，效率奇高，i(nner)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dtx&lt;/code&gt; 删除字符直到遇见光标之后的第一个&lt;code&gt;x&lt;/code&gt;字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ytx&lt;/code&gt; 复制字符直到遇见光标之后的第一个&lt;code&gt;x&lt;/code&gt;字符&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;标记和宏(macro)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ma&lt;/code&gt; 将当前位置标记为a，26个字母均可做标记，&lt;code&gt;mb&lt;/code&gt;、&lt;code&gt;mc&lt;/code&gt;等等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;a&lt;/code&gt; 跳转到a标记的位置；&lt;/li&gt;
&lt;li&gt;这是一组很好的文档内标记方法，在文档中跳跃编辑时很有用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;qa&lt;/code&gt; 将之后的所有键盘操作录制下来，直到再次在命令模式按下&lt;code&gt;q&lt;/code&gt;，并存储在&lt;code&gt;a&lt;/code&gt;中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@a&lt;/code&gt; 执行刚刚记录在&lt;code&gt;a&lt;/code&gt;里面的键盘操作；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@@&lt;/code&gt; 执行上一次的macro操作；&lt;/li&gt;
&lt;li&gt;宏操作是VIM最为神奇的操作之一，需要慢慢体会其强大之处；&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;VIM的基本操作，可以挖掘的东西非常多，不仅仅需要记忆，更需要自己去探索总结，熟练之后，效率会大幅度提升。后面会给出一些参考链接。&lt;/p&gt;

&lt;h2&gt;插件管理&lt;/h2&gt;

&lt;h3&gt;Vundle&lt;/h3&gt;

&lt;p&gt;终于到这篇Blog我最想讨论的部分了。VIM的强大不仅仅体现在操作的高效率，更有强大而充沛的插件做支援，插件丰富了之后，就面临查找和管理的问题。&lt;/p&gt;

&lt;p&gt;在遇见&lt;a href=&quot;https://github.com/gmarik/vundle&quot;&gt;Vundle&lt;/a&gt;之前，我用&lt;a href=&quot;https://github.com/tpope/vim-pathogen&quot;&gt;Pathogen&lt;/a&gt;管理插件。Pathogen还算方便，只需要把相应插件，放在&lt;code&gt;bundle&lt;/code&gt;目录下即可，不需要再像以前那样逐个放置单独的文件到相应目录，大大节省了劳动力，管理起来也一目了然，觉得还不错，至少比vimball那种需要执行命令安装的方式好一些。&lt;/p&gt;

&lt;p&gt;我真希望我早些遇见Vundle。Vundle受到Pathogen和Vimball的启发，于是有了现在的模样。Vundle的逻辑是这样的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;a href=&quot;http://vim-scripts.org/vim/scripts.html&quot;&gt;Vim Script&lt;/a&gt;选好你想要的插件；&lt;/li&gt;
&lt;li&gt;在VIM的配置文件中写一句 &lt;code&gt;Bundle plugin_name&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;执行一下Vundle的初始化命令，插件就装好了；&lt;/li&gt;
&lt;li&gt;升级和卸载也是同样的简单；&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;完美的世界！&lt;/p&gt;

&lt;h3&gt;Vundle的配置&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/gmarik/vundle&quot;&gt;Vundle&lt;/a&gt;的安装很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone http://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后写配置文件&lt;code&gt;.vimrc&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set nocompatible    &quot; be iMproved
filetype off        &quot; required!

set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

&quot; let Vundle manage Vundle
&quot; required!
Bundle &#39;gmarik/vundle&#39;

&quot; vim-scripts repos
Bundle &#39;vim-plugin-foo&#39;
Bundle &#39;vim-plugin-bar&#39;

filetype plugin indent on    &quot; required!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;Bundle&lt;/code&gt;后面的内容，就是插件的名字，插件维护在&lt;a href=&quot;http://vim-scripts.org/vim/scripts.html&quot;&gt;Vim-Script.org&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;然后，打开VIM之后，可以输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;安装插件:
:BundleInstall

&quot;更新插件:
:BundleInstall!

&quot;卸载不在列表中的插件:
:BundleClean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在大部分的插件都已经从&lt;a href=&quot;http://www.vim.org/scripts/index.php&quot;&gt;Vim.org&lt;/a&gt;迁移到了&lt;a href=&quot;http://vim-scripts.org/vim/scripts.html&quot;&gt;Vim-Script.org&lt;/a&gt;，而且很多作者也认领了自己的插件，直接在这个Github的项目下更新，一个比Vim.org更科学更有效的生态环境，就这样完美的形成了。&lt;/p&gt;

&lt;p&gt;在此非常严重的感谢vim-scripts.org的创建者&lt;a href=&quot;https://github.com/bronson&quot;&gt;Scott Bronson&lt;/a&gt;，和&lt;a href=&quot;https://github.com/gmarik/vundle&quot;&gt;Vundle&lt;/a&gt;的作者&lt;a href=&quot;https://github.com/gmarik&quot;&gt;gmarik&lt;/a&gt;。他们的创新和分享精神，让这个世界又美好了一些。&lt;/p&gt;

&lt;p&gt;也感谢业界良心&lt;a href=&quot;https://github.com/&quot;&gt;Github&lt;/a&gt;。Vim-Scripts.org整站就是用&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;建立维护的，对于个人来说，这是很好的选择，有兴趣的同学可以参看我之前的博客：&lt;a href=&quot;http://beiyuu.com/github-pages/&quot;&gt;使用Github Pages建独立博客&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;插件介绍&lt;/h2&gt;

&lt;p&gt;有了Vundle，再装插件就是件享受的事情了。我常用的插件有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#相较于Command-T等查找文件的插件，ctrlp.vim最大的好处在于没有依赖，干净利落
Bundle &#39;ctrlp.vim&#39;

#在输入()，&quot;&quot;等需要配对的符号时，自动帮你补全剩余半个
Bundle &#39;AutoClose&#39;

#神级插件，ZenCoding可以让你以一种神奇而无比爽快的感觉写HTML、CSS
Bundle &#39;ZenCoding.vim&#39;

#在()、&quot;&quot;、甚至HTML标签之间快速跳转；
Bundle &#39;matchit.zip&#39;

#显示行末的空格；
Bundle &#39;ShowTrailingWhitespace&#39;

#JS代码格式化插件；
Bundle &#39;_jsbeautify&#39;

#用全新的方式在文档中高效的移动光标，革命性的突破
Bundle &#39;EasyMotion&#39;

#自动识别文件编码；
Bundle &#39;FencView.vim&#39;

#必不可少，在VIM的编辑窗口树状显示文件目录
Bundle &#39;The-NERD-tree&#39;

#NERD出品的快速给代码加注释插件，选中，`ctrl+h`即可注释多种语言代码；
Bundle &#39;The-NERD-Commenter&#39;

#解放生产力的神器，简单配置，就可以按照自己的风格快速输入大段代码。
Bundle &#39;UltiSnips&#39;

#让代码更加易于纵向排版，以=或,符号对齐
Bundle &#39;Tabular&#39;

#迄今位置最好的自动VIM自动补全插件了吧
#Vundle的这个写法，是直接取该插件在Github上的repo
Bundle &#39;Valloric/YouCompleteMe&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上插件可以在&lt;a href=&quot;http://vim-scripts.org/vim/scripts.html&quot;&gt;vim-script.org&lt;/a&gt;找到源码和文档，&lt;a href=&quot;http://mattn.github.com/zencoding-vim/&quot;&gt;ZenCoding&lt;/a&gt;和&lt;a href=&quot;http://net.tutsplus.com/tutorials/other/vim-essential-plugin-easymotion/&quot;&gt;EasyMotion&lt;/a&gt;演示点链接,你会心动的。&lt;/p&gt;

&lt;h2&gt;.vimrc配置&lt;/h2&gt;

&lt;p&gt;因为配置不断在更新，所以放上我的配置的链接：&lt;a href=&quot;https://github.com/beiyuu/vimfiles/blob/master/_vimrc&quot;&gt;.vimrc配置&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;更多&lt;/h2&gt;

&lt;p&gt;VIM在一开始会觉得非常不习惯，一定要坚持下去，收获的会更多，不仅仅是在装大侠方面的哦~&lt;/p&gt;

&lt;p&gt;关于VIM的使用，这篇博客仅仅介绍了很小的一部分，网络上还有大量朋友总结的心得，常学常有收获：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/10599776/&quot;&gt;Practical Vim&lt;/a&gt;，强烈推荐的一本系统介绍VIM的书籍&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/vim/&quot;&gt;Vim Cheat Sheet&lt;/a&gt;，有VIM的各种助记图，可以作为桌面&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.vimer.cn/&quot;&gt;Vimer的程序世界&lt;/a&gt;，不错的站，博主持续钻研VIM各种技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hi.baidu.com/whqvzhjoixbbdwd/item/11315a5073667d0de6c4a5e9&quot;&gt;网友狂人收集的vim资料链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.rayninfo.co.uk/vimtips.html&quot;&gt;Best of Vim Tips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.limboy.com/2009/05/30/vim-setting/&quot;&gt;面向前端开发者和TextMate粉丝的vim配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://scmbob.org/vim_fdm.html&quot;&gt;Vim代码折叠简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.longwin.com.tw/2009/03/choose-vim-color-scheme-2009/&quot;&gt;挑選 Vim 顏色(Color Scheme)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb&quot;&gt;vimium&lt;/a&gt;，用VIM的操作习惯来控制Chrome的插件&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>谈谈刚需和360影视</title>
     <link href="http://blog.11010.net/needs-video"/>
     <updated>2012-11-22T00:00:00+08:00</updated>
     <id>http://beiyuu.com/needs-video</id>
     <content type="html">&lt;h2&gt;很久以前&lt;/h2&gt;

&lt;p&gt;很欠的说，一年半之前，我非常想做影视导航站，构思也近完整。当时试用了几个同类站，基本上能确定，这些产品经理不追美剧。&lt;a href=&quot;http://v.360.cn&quot;&gt;360影视&lt;/a&gt;在2011年4月下旬发布，跟我的想法同期，不过我发现他却是几个月之后了。&lt;/p&gt;

&lt;h2&gt;需求很简单&lt;/h2&gt;

&lt;p&gt;对于追剧集的来说，需求其实很简单：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;找到需要的剧集&lt;/li&gt;
&lt;li&gt;在线看地址或下载链接（在线最好）&lt;/li&gt;
&lt;li&gt;记住我看到哪了&lt;/li&gt;
&lt;li&gt;更新及时&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这样简单的需求，那么多站做的我连吐槽的兴趣都没有。好吧，360影视满足了上面的需求，所以我用他，又因为我用，所以才吐槽：&lt;/p&gt;

&lt;h2&gt;吐槽360影视&lt;/h2&gt;

&lt;h3&gt;一个剧集&lt;/h3&gt;

&lt;p&gt;各站对一个剧集有多季的处理，除了豆瓣电影可以方便完整的链接到其他季，其他各站几乎都独立了每一季，这是糟糕的体验，人为增大&lt;strong&gt; “找到需要的剧集” &lt;/strong&gt;的难度。看下图：
&lt;img src=&quot;/images/360video/sp-search.jpg&quot; alt=&quot;ssh key success&quot; /&gt;
我是不会明白这样做的好处，得到的只是难受、难受。&lt;/p&gt;

&lt;h3&gt;new标识&lt;/h3&gt;

&lt;p&gt;new标识绝对是互联网上最被滥用的图标之一。有些地方用的真让人莫名的恼火：
&lt;img src=&quot;/images/360video/baidu-new.jpg&quot; alt=&quot;ssh key success&quot; /&gt;
这是百度首页网址导航的new标识，难以理解，猜测他根据我的浏览记录来决定是否显示new，但是Big Bang我看过了却还显示，所以这个逻辑行不通，只好猜测他是根据绝对时间的new程度来显示，这就无法满足&lt;strong&gt; “记住我看到哪了” &lt;/strong&gt;需求，如果我有很久一段时间没看，提示失去了参考意义，而且点一下链接，new就会消失，我只能呵呵了。完全不可用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/360video/2b-sohu.jpg&quot; alt=&quot;ssh key success&quot; /&gt;
再看搜狐视频的new标识，3、4集都标上了new，你却根本不管我到底看了没，看过3了，3上面的new还在，也是混乱了正常秩序，没有安全感，不靠谱。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/360video/2b-360.jpg&quot; alt=&quot;ssh key success&quot; /&gt;
360影视的这个new的定义也很奇怪，我看过了new还在，过了两个星期了new也还在，我只能推断他的逻辑就是，最新的一集就是需要标new的那一集，真把用户当白痴了，不过他稍好一点的是，这个毫无意义的标识不会捣乱。&lt;/p&gt;

&lt;p&gt;那到底怎样做才好呢，既然每个剧集里面会标明看过与否，那么在我正在追的美剧的集合页，明确的告诉我，我赶上最新一集某剧还差多少就好了啊。
&lt;img src=&quot;/images/360video/new-out.jpg&quot; alt=&quot;ssh key success&quot; /&gt;
看到这，也就能体会独立每一季出来有多恶心了。&lt;/p&gt;

&lt;h3&gt;注册用户&lt;/h3&gt;

&lt;p&gt;我明白，像这样一个刚需产品，又通过360浏览器导航过来的，大多都是低端用户，首页做成那个样子无可厚非，可是当我顶着极大的不情愿注册了用户之后，能不能稍微体谅下注册用户的心呢？&lt;/p&gt;

&lt;p&gt;我猜想根据产品的设计，用户注册就是为了标记自己想看的剧集，方便更快更准的追剧，可是每次打开还是那个国产垃圾横行的首页，你让小清新们怎么看的上呢？&lt;/p&gt;

&lt;p&gt;好啦，我就忍一下，多点一下“我的影视”吧：
&lt;img src=&quot;/images/360video/360-home.jpg&quot; alt=&quot;ssh key success&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现问题没，把我主动标记了的影视放在下面，要把那些自作聪明的推荐作品放在上面，并且一个都没有推荐，这不是耍流氓的干活还是什么滴干活？&lt;/p&gt;

&lt;p&gt;再综合上面new标识最后一条，基本上，网站的使用效率被这些恶心的细节全面拉低，需要很多无谓的操作，才能到达我的真正目的。&lt;/p&gt;

&lt;h3&gt;安全感&lt;/h3&gt;

&lt;p&gt;我最近比较喜欢用安全感这个概念，大意就是我在乎的事情你都能很好的解决，并不需要我过多的操心。
&lt;img src=&quot;/images/360video/homeland.jpg&quot; alt=&quot;ssh key success&quot; /&gt;
看过与否倒是一目了然，可当我只是看了几眼，并不想接着看下去，或者手贱点了后面的某一集，我就得人肉去记住，我没看过第一集，只是手贱点了一下，下次想看的时候得从第一集看，一定要记得，一定。&lt;/p&gt;

&lt;p&gt;呵呵，那我还要你记干嘛呢？&lt;/p&gt;

&lt;h2&gt;顺道吐槽社交&lt;/h2&gt;

&lt;p&gt;看到这个需求人很多，在移动端尤甚。有个叫“段落”的电视导航应用，主要功能是电视节目早知道，现在电视节目有精彩到需要看着预告时间等的程度吗？我表示怀疑。不过“段落”主打的是社交，可以跟同时看“非诚勿扰”的观众交流哦~&lt;/p&gt;

&lt;p&gt;我只想说，&lt;strong&gt;社你妈X交&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;真有那么困难吗&lt;/h2&gt;

&lt;p&gt;是的，这个命题很难以理解，来看看百度视频的例子，美剧在百度的搜索量肯定不小：
&lt;img src=&quot;/images/360video/baidu-search.jpg&quot; alt=&quot;ssh key success&quot; /&gt;
继续吐槽那个无法理解的new标识，总体看起来不错哦，提供了好几个视频服务商，点开过的链接，自然的变不同颜色，看起来很自然，但是满足 &lt;strong&gt;“记住我看到哪儿”&lt;/strong&gt; 的需求还是不可靠，就没有安全感。&lt;/p&gt;

&lt;p&gt;再看看假如我要追一个剧集，那么在百度视频里面该怎么做呢？
&lt;img src=&quot;/images/360video/baidu-video.jpg&quot; alt=&quot;ssh key success&quot; /&gt;
点了，好久，终于发现了这个藏起来的“订阅”按钮，订阅，订阅，呵呵，订阅！&lt;/p&gt;

&lt;p&gt;在回到百度视频的首页，我是无法找到我刚才的“订阅”操作，对首页有任何影响，参考上面的“注册用户”一节，百度首页上也没什么特别的变化，所以，至此，我不知道这个订阅按钮到底有什么作用。&lt;/p&gt;

&lt;p&gt;百度视频首页，在众多傻逼一样的new标识之下，我还是被吸引到了一个叫“我的随心看”的频道，以为可以快速打开我订阅的剧集，原来是“豆瓣猜”啊，混乱至极。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;本来想心平气和的吐槽下，毕竟360影视做的正常的地方还是有的，可是说着说着还是不免激动了，哎。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>使用Github Pages建独立博客</title>
     <link href="http://blog.11010.net/github-pages"/>
     <updated>2012-02-22T00:00:00+08:00</updated>
     <id>http://beiyuu.com/github-pages</id>
     <content type="html">&lt;p&gt;&lt;a href=&quot;http://github.com&quot; title=&quot;Github&quot;&gt;Github&lt;/a&gt;很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如&lt;a href=&quot;https://github.com/jquery/jquery&quot; title=&quot;jQuery@github&quot;&gt;jQuery&lt;/a&gt;、&lt;a href=&quot;https://github.com/twitter/bootstrap&quot; title=&quot;Twitter@github&quot;&gt;Twitter&lt;/a&gt;等。为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，Github替你想到了这一点，他提供了&lt;a href=&quot;http://pages.github.com/&quot; title=&quot;Github Pages&quot;&gt;Github Pages&lt;/a&gt;的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。&lt;/p&gt;

&lt;p&gt;Github Pages有以下几个优点：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;轻量级的博客系统，没有麻烦的配置&lt;/li&gt;
    &lt;li&gt;使用标记语言，比如&lt;a href=&quot;http://markdown.tw&quot;&gt;Markdown&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;无需自己搭建服务器&lt;/li&gt;
    &lt;li&gt;根据Github的限制，对应的每个站有300MB空间&lt;/li&gt;
    &lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当然他也有缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&quot;https://github.com/mojombo/jekyll&quot; title=&quot;Jekyll&quot;&gt;Jekyll&lt;/a&gt;模板系统，相当于静态页发布，适合博客，文档介绍等。&lt;/li&gt;
&lt;li&gt;动态程序的部分相当局限，比如没有评论，不过还好我们有解决方案。&lt;/li&gt;
&lt;li&gt;基于Git，很多东西需要动手，不像Wordpress有强大的后台&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;大致介绍到此，作为个人博客来说，简洁清爽的表达自己的工作、心得，就已达目标，所以Github Pages是我认为此需求最完美的解决方案了。&lt;/p&gt;

&lt;h2&gt;购买、绑定独立域名&lt;/h2&gt;

&lt;p&gt;虽说&lt;a href=&quot;http://www.godaddy.com/&quot; title=&quot;Godaddy&quot;&gt;Godaddy&lt;/a&gt;曾支持过SOPA，并且首页放着极其不专业的大胸美女，但是作为域名服务商他做的还不赖，选择它最重要的原因是他支持支付宝，没有信用卡有时真的很难过。&lt;/p&gt;

&lt;p&gt;域名的购买不用多讲，注册、选域名、支付，有网购经验的都毫无压力，优惠码也遍地皆是。域名的配置需要提醒一下，因为伟大英明的GFW的存在，我们必须多做些事情。&lt;/p&gt;

&lt;p&gt;流传Godaddy的域名解析服务器被墙掉，导致域名无法访问，后来这个事情在&lt;a href=&quot;http://beiyuu.com&quot; title=&quot;BeiYuu&quot;&gt;BeiYuu&lt;/a&gt;也发生了，不得已需要把域名解析服务迁移到国内比较稳定的服务商处，这个迁移对于域名来说没有什么风险，最终的控制权还是在Godaddy那里，你随时都可以改回去。&lt;/p&gt;

&lt;p&gt;我们选择&lt;a href=&quot;https://www.dnspod.cn/&quot; title=&quot;DNSPod&quot;&gt;DNSPod&lt;/a&gt;的服务，他们的产品做得不错，易用、免费，收费版有更高端的功能，暂不需要。注册登录之后，按照DNSPod的说法，只需三步（我们插入一步）：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;首先添加域名记录，可参考DNSPod的帮助文档：&lt;a href=&quot;https://www.dnspod.cn/Support&quot;&gt;https://www.dnspod.cn/Support&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;在DNSPod自己的域名下添加一条&lt;a href=&quot;http://baike.baidu.com/view/65575.htm&quot;&gt;A记录&lt;/a&gt;，地址就是Github Pages的服务IP地址：207.97.227.245&lt;/li&gt;
    &lt;li&gt;在域名注册商处修改DNS服务:去Godaddy修改Nameservers为这两个地址：f1g1ns1.dnspod.net、f1g1ns2.dnspod.net。如果你不明白在哪里修改，可以参考这里：&lt;a href=&quot;https://www.dnspod.cn/support/index/fid/119&quot;&gt;Godaddy注册的域名如何使用DNSPod&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;等待域名解析生效&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;域名的配置部分完成，跪谢方校长。&lt;/p&gt;

&lt;h2&gt;配置和使用Github&lt;/h2&gt;

&lt;p&gt;Git是版本管理的未来，他的优点我不再赘述，相关资料很多。推荐这本&lt;a href=&quot;http://progit.org/book/zh/&quot; title=&quot;Pro Git中文版&quot;&gt;Git中文教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要使用Git，需要安装它的客户端，推荐在Linux下使用Git，会比较方便。Windows版的下载地址在这里：&lt;a href=&quot;http://code.google.com/p/msysgit/downloads/list&quot; title=&quot;Windows版Git客户端&quot;&gt;http://code.google.com/p/msysgit/downloads/list&lt;/a&gt;。其他系统的安装也可以参考官方的&lt;a href=&quot;http://help.github.com/mac-set-up-git/&quot; title=&quot;Mac下Git安装&quot;&gt;安装教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下载安装客户端之后，各个系统的配置就类似了，我们使用windows作为例子，Linux和Mac与此类似。&lt;/p&gt;

&lt;p&gt;在Windows下，打开Git Bash，其他系统下面则打开终端（Terminal）：
&lt;img src=&quot;/images/githubpages/bootcamp_1_win_gitbash.jpg&quot; alt=&quot;Git Bash&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;1、检查SSH keys的设置&lt;/h3&gt;

&lt;p&gt;首先我们需要检查你电脑上现有的ssh key：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/.ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果显示“No such file or directory”，跳到第三步，否则继续。&lt;/p&gt;

&lt;h3&gt;2、备份和移除原来的ssh key设置：&lt;/h3&gt;

&lt;p&gt;因为已经存在key文件，所以需要备份旧的数据并删除：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
config  id_rsa  id_rsa.pub  known_hosts
$ mkdir key_backup
$ cp id_rsa* key_backup
$ rm id_rsa*
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3、生成新的SSH Key：&lt;/h3&gt;

&lt;p&gt;输入下面的代码，就可以生成新的key文件，我们只需要默认设置就好，所以当需要输入文件名的时候，回车就好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&amp;lt;回车就好&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后系统会要你输入加密串（&lt;a href=&quot;http://help.github.com/ssh-key-passphrases/&quot;&gt;Passphrase&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enter passphrase (empty for no passphrase):&amp;lt;输入加密串&amp;gt;
Enter same passphrase again:&amp;lt;再次输入加密串&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后看到这样的界面，就成功设置ssh key了：
&lt;img src=&quot;/images/githubpages/ssh-key-set.png&quot; alt=&quot;ssh key success&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;4、添加SSH Key到GitHub：&lt;/h3&gt;

&lt;p&gt;在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。&lt;/p&gt;

&lt;p&gt;用文本编辑工具打开id_rsa.pub文件，如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。&lt;/p&gt;

&lt;p&gt;在GitHub的主页上点击设置按钮：
&lt;img src=&quot;/images/githubpages/github-account-setting.png&quot; alt=&quot;github account setting&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择SSH Keys项，把复制的内容粘贴进去，然后点击Add Key按钮即可：
&lt;img src=&quot;/images/githubpages/bootcamp_1_ssh.jpg&quot; alt=&quot;set ssh keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PS：如果需要配置多个GitHub账号，可以参看这个&lt;a href=&quot;http://omiga.org/blog/archives/2269&quot;&gt;多个github帐号的SSH key切换&lt;/a&gt;，不过需要提醒一下的是，如果你只是通过这篇文章中所述配置了Host，那么你多个账号下面的提交用户会是一个人，所以需要通过命令&lt;code&gt;git config --global --unset user.email&lt;/code&gt;删除用户账户设置，在每一个repo下面使用&lt;code&gt;git config --local user.email &#39;你的github邮箱@mail.com&#39;&lt;/code&gt; 命令单独设置用户账户信息&lt;/p&gt;

&lt;h3&gt;5、测试一下&lt;/h3&gt;

&lt;p&gt;可以输入下面的命令，看看设置是否成功，&lt;code&gt;git@github.com&lt;/code&gt;的部分不要修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是下面的反应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要紧张，输入&lt;code&gt;yes&lt;/code&gt;就好，然后会看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi &amp;lt;em&amp;gt;username&amp;lt;/em&amp;gt;! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6、设置你的账号信息&lt;/h3&gt;

&lt;p&gt;现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。&lt;/p&gt;

&lt;p&gt;Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;你的名字&quot;
$ git config --global user.email &quot;your_email@youremail.com&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;设置GitHub的token&lt;/h4&gt;

&lt;p&gt;2012-4-28补充：新版的接口已经不需要配置token了，所以下面这段可以跳过了&lt;/p&gt;

&lt;p&gt;有些工具没有通过SSH来链接GitHub。如果要使用这类工具，你需要找到然后设置你的API Token。&lt;/p&gt;

&lt;p&gt;在GitHub上，你可以点击&lt;em&gt;Account Setting &gt; Account Admin&lt;/em&gt;：
&lt;img src=&quot;/images/githubpages/bootcamp_1_token.jpg&quot; alt=&quot;set ssh keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后在你的命令行中，输入下面的命令，把token添加进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;你的名字&quot;
$ git config --global user.token 0123456789your123456789token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你改了GitHub的密码，需要重新设置token。&lt;/p&gt;

&lt;h3&gt;成功了&lt;/h3&gt;

&lt;p&gt;好了，你已经可以成功连接GitHub了。&lt;/p&gt;

&lt;h2&gt;使用GitHub Pages建立博客&lt;/h2&gt;

&lt;p&gt;与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务，GitHub Pages分两种，一种是你的GitHub用户名建立的&lt;code&gt;username.github.io&lt;/code&gt;这样的用户&amp;amp;组织页（站），另一种是依附项目的pages。&lt;/p&gt;

&lt;h3&gt;User &amp;amp; Organization Pages&lt;/h3&gt;

&lt;p&gt;想建立个人博客是用的第一种，形如&lt;code&gt;beiyuu.github.io&lt;/code&gt;这样的可访问的站，每个用户名下面只能建立一个，创建之后点击&lt;code&gt;Admin&lt;/code&gt;进入项目管理，可以看到是这样的：
&lt;img src=&quot;/images/githubpages/user-pages.png&quot; alt=&quot;user pages&quot; /&gt;
而普通的项目是这样的，即使你也是用的&lt;code&gt;othername.github.io&lt;/code&gt;：
&lt;img src=&quot;/images/githubpages/other-pages.png&quot; alt=&quot;other pages&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建好&lt;code&gt;username.github.io&lt;/code&gt;项目之后，提交一个&lt;code&gt;index.html&lt;/code&gt;文件，然后&lt;code&gt;push&lt;/code&gt;到GitHub的&lt;code&gt;master&lt;/code&gt;分支（也就是普通意义上的主干）。第一次页面生效需要一些时间，大概10分钟左右。&lt;/p&gt;

&lt;p&gt;生效之后，访问&lt;code&gt;username.github.io&lt;/code&gt;就可以看到你上传的页面了，&lt;a href=&quot;http://beiyuu.github.com&quot;&gt;beiyuu.github.com&lt;/a&gt;就是一个例子。&lt;/p&gt;

&lt;p&gt;关于第二种项目&lt;code&gt;pages&lt;/code&gt;，简单提一下，他和用户pages使用的后台程序是同一套，只不过它的目的是项目的帮助文档等跟项目绑定的内容，所以需要在项目的&lt;code&gt;gh-pages&lt;/code&gt;分支上去提交相应的文件，GitHub会自动帮你生成项目pages。具体的使用帮助可以参考&lt;a href=&quot;http://pages.github.com/&quot; title=&quot;Github Pages&quot;&gt;Github Pages&lt;/a&gt;的官方文档：&lt;/p&gt;

&lt;h3&gt;绑定域名&lt;/h3&gt;

&lt;p&gt;我们在第一部分就提到了在DNS部分的设置，再来看在GitHub的配置，要想让&lt;code&gt;username.github.io&lt;/code&gt;能通过你自己的域名来访问，需要在项目的根目录下新建一个名为&lt;code&gt;CNAME&lt;/code&gt;的文件，文件内容形如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beiyuu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以绑定在二级域名上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;blog.beiyuu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要提醒的一点是，如果你使用形如&lt;code&gt;beiyuu.com&lt;/code&gt;这样的一级域名的话，需要在DNS处设置A记录到&lt;code&gt;207.97.227.245&lt;/code&gt;（&lt;strong&gt;这个地址会有变动，&lt;a href=&quot;https://help.github.com/articles/my-custom-domain-isn-t-working&quot;&gt;这里&lt;/a&gt;查看&lt;/strong&gt;），而不是在DNS处设置为CNAME的形式，否则可能会对其他服务（比如email）造成影响。&lt;/p&gt;

&lt;p&gt;设置成功后，根据DNS的情况，最长可能需要一天才能生效，耐心等待吧。&lt;/p&gt;

&lt;h2&gt;Jekyll模板系统&lt;/h2&gt;

&lt;p&gt;GitHub Pages为了提供对HTML内容的支持，选择了&lt;a href=&quot;https://github.com/mojombo/jekyll&quot; title=&quot;Jekyll&quot;&gt;Jekyll&lt;/a&gt;作为模板系统，Jekyll是一个强大的静态模板系统，作为个人博客使用，基本上可以满足要求，也能保持管理的方便，你可以查看&lt;a href=&quot;https://github.com/mojombo/jekyll/blob/master/README.textile&quot;&gt;Jekyll官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;你可以直接fork&lt;a href=&quot;https://github.com/beiyuu/beiyuu.github.com&quot;&gt;我的项目&lt;/a&gt;，然后改名，就有了你自己的满足Jekyll要求的文档了，当然你也可以按照下面的介绍自己创建。&lt;/p&gt;

&lt;h3&gt;Jekyll基本结构&lt;/h3&gt;

&lt;p&gt;Jekyll的核心其实就是一个文本的转换引擎，用你最喜欢的标记语言写文档，可以是Markdown、Textile或者HTML等等，再通过&lt;code&gt;layout&lt;/code&gt;将文档拼装起来，根据你设置的URL规则来展现，这些都是通过严格的配置文件来定义，最终的产出就是web页面。&lt;/p&gt;

&lt;p&gt;基本的Jekyll结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   `-- post.html
|-- _posts
|   |-- 2007-10-29-why-every-programmer-should-play-nethack.textile
|   `-- 2009-04-26-barcamp-boston-4-roundup.textile
|-- _site
`-- index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单介绍一下他们的作用：&lt;/p&gt;

&lt;h4&gt;_config.yml&lt;/h4&gt;

&lt;p&gt;配置文件，用来定义你想要的效果，设置之后就不用关心了。&lt;/p&gt;

&lt;h4&gt;_includes&lt;/h4&gt;

&lt;p&gt;可以用来存放一些小的可复用的模块，方便通过&lt;code&gt;{ % include file.ext %}&lt;/code&gt;（去掉前两个{中或者{与%中的空格，下同）灵活的调用。这条命令会调用_includes/file.ext文件。&lt;/p&gt;

&lt;h4&gt;_layouts&lt;/h4&gt;

&lt;p&gt;这是模板文件存放的位置。模板需要通过&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML front matter&lt;/a&gt;来定义，后面会讲到，&lt;code&gt;{ { content }}&lt;/code&gt;标记用来将数据插入到这些模板中来。&lt;/p&gt;

&lt;h4&gt;_posts&lt;/h4&gt;

&lt;p&gt;你的动态内容，一般来说就是你的博客正文存放的文件夹。他的命名有严格的规定，必须是&lt;code&gt;2012-02-22-artical-title.MARKUP&lt;/code&gt;这样的形式，MARKUP是你所使用标记语言的文件后缀名，根据_config.yml中设定的链接规则，可以根据你的文件名灵活调整，文章的日期和标记语言后缀与文章的标题的独立的。&lt;/p&gt;

&lt;h4&gt;_site&lt;/h4&gt;

&lt;p&gt;这个是Jekyll生成的最终的文档，不用去关心。最好把他放在你的&lt;code&gt;.gitignore&lt;/code&gt;文件中忽略它。&lt;/p&gt;

&lt;h4&gt;其他文件夹&lt;/h4&gt;

&lt;p&gt;你可以创建任何的文件夹，在根目录下面也可以创建任何文件，假设你创建了&lt;code&gt;project&lt;/code&gt;文件夹，下面有一个&lt;code&gt;github-pages.md&lt;/code&gt;的文件，那么你就可以通过&lt;code&gt;yoursite.com/project/github-pages&lt;/code&gt;访问的到，如果你是使用一级域名的话。文件后缀可以是&lt;code&gt;.html&lt;/code&gt;或者&lt;code&gt;markdown&lt;/code&gt;或者&lt;code&gt;textile&lt;/code&gt;。这里还有很多的例子：&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;https://github.com/mojombo/jekyll/wiki/Sites&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Jekyll的配置&lt;/h3&gt;

&lt;p&gt;Jekyll的配置写在_config.yml文件中，可配置项有很多，我们不去一一追究了，很多配置虽有用但是一般不需要去关心，&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/configuration&quot;&gt;官方配置文档&lt;/a&gt;有很详细的说明，确实需要了可以去这里查，我们主要说两个比较重要的东西，一个是&lt;code&gt;Permalink&lt;/code&gt;，还有就是自定义项。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Permalink&lt;/code&gt;项用来定义你最终的文章链接是什么形式，他有下面几个变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;year&lt;/code&gt; 文件名中的年份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;month&lt;/code&gt; 文件名中的月份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;day&lt;/code&gt; 文件名中的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;title&lt;/code&gt; 文件名中的文章标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;categories&lt;/code&gt; 文章的分类，如果文章没有分类，会忽略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i-month&lt;/code&gt; 文件名中的除去前缀0的月份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i-day&lt;/code&gt; 文件名中的除去前缀0的日期&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;看看最终的配置效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink: pretty&lt;/code&gt; /2009/04/29/slap-chop/index.html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;permalink: /:month-:day-:year/:title.html&lt;/code&gt; /04-29-2009/slap-chop.html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;permalink: /blog/:year/:month/:day/:title&lt;/code&gt; /blog/2009/04/29/slap-chop/index.html&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我使用的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink: /:title&lt;/code&gt; /github-pages&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;自定义项的内容，例如我们定义了&lt;code&gt;title:BeiYuu的博客&lt;/code&gt;这样一项，那么你就可以在文章中使用&lt;code&gt;{ { site.title }}&lt;/code&gt;来引用这个变量了，非常方便定义些全局变量。&lt;/p&gt;

&lt;h3&gt;YAML Front Matter和模板变量&lt;/h3&gt;

&lt;p&gt;对于使用YAML定义格式的文章，Jekyll会特别对待，他的格式要求比较严格，必须是这样的形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: Blogging Like a Hacker
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前后的&lt;code&gt;---&lt;/code&gt;不能省略，在这之间，你可以定一些你需要的变量，layout就是调用&lt;code&gt;_layouts&lt;/code&gt;下面的某一个模板，他还有一些其他的变量可以使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink&lt;/code&gt; 你可以对某一篇文章使用通用设置之外的永久链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;published&lt;/code&gt; 可以单独设置某一篇文章是否需要发布&lt;/li&gt;
&lt;li&gt;&lt;code&gt;category&lt;/code&gt; 设置文章的分类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt; 设置文章的tag&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;上面的&lt;code&gt;title&lt;/code&gt;就是自定义的内容，你也可以设置其他的内容，在文章中可以通过&lt;code&gt;{ { page.title }}&lt;/code&gt;这样的形式调用。&lt;/p&gt;

&lt;p&gt;模板变量，我们之前也涉及了不少了，还有其他需要的变量，可以参考官方的文档：&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/template-data&quot; title=&quot;Jekyll Template Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/template-data&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;使用Disqus管理评论&lt;/h2&gt;

&lt;p&gt;模板部分到此就算是配置完毕了，但是Jekyll只是个静态页面的发布系统，想做到关爽场倒是很容易，如果想要评论呢？也很简单。&lt;/p&gt;

&lt;p&gt;现在专做评论模块的产品有很多，比如&lt;a href=&quot;http://disqus.com/&quot;&gt;Disqus&lt;/a&gt;，还有国产的&lt;a href=&quot;http://duoshuo.com/&quot;&gt;多说&lt;/a&gt;，Disqus对现在各种系统的支持都比较全面，到写博客为止，多说现在仅是WordPress的一个插件，所以我这里暂时也使用不了，多说与国内的社交网络紧密结合，还是有很多亮点的，值得期待一下。我先选择了Disqus。&lt;/p&gt;

&lt;p&gt;注册账号什么的就不提了，Disqus支持很多的博客平台，参见下图：
&lt;img src=&quot;/images/githubpages/disqus-site.jpg&quot; alt=&quot;Disqus sites&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们选择最下面的&lt;code&gt;Universal Code&lt;/code&gt;就好，然后会看到一个介绍页面，把下面这段代码复制到你的模板里面，可以只复制到显示文章的模板中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;disqus_thread&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = &#39;example&#39;; // required: replace example with your forum shortname 这个地方需要改成你配置的网站名

    /* * * DON&#39;T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement(&#39;script&#39;); dsq.type = &#39;text/javascript&#39;; dsq.async = true;
        dsq.src = &#39;http://&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;;
        (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);
    })();
&amp;lt;/script&amp;gt;
&amp;lt;noscript&amp;gt;Please enable JavaScript to view the &amp;lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&amp;gt;comments powered by Disqus.&amp;lt;/a&amp;gt;&amp;lt;/noscript&amp;gt;
&amp;lt;a href=&quot;http://disqus.com&quot; class=&quot;dsq-brlink&quot;&amp;gt;blog comments powered by &amp;lt;span class=&quot;logo-disqus&quot;&amp;gt;Disqus&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完之后，你也可以做一些异步加载的处理，提高性能，比如我就在最开始页面打开的时候不显示评论，当你想看评论的时候，点击“显示评论”再加载Disqus的模块。代码很简单，你可以参考我的写法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;#disqus_container .comment&#39;).on(&#39;click&#39;,function(){
        $(this).html(&#39;加载中...&#39;);
        var disqus_shortname = &#39;beiyuu&#39;;
        var that = this;
        BYB.includeScript(&#39;http://&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;,function(){$(that).remove()}); //这是一个加载js的函数
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不喜欢Disqus的样式，你也可以根据他生成的HTML结构，自己改写样式覆盖它的，Disqus现在也提供每个页面的评论数接口，&lt;a href=&quot;http://docs.disqus.com/developers/universal/&quot;&gt;帮助文档&lt;/a&gt;在这里可以看到。&lt;/p&gt;

&lt;h2&gt;代码高亮插件&lt;/h2&gt;

&lt;p&gt;如果写技术博客，代码高亮少不了，有两个可选插件&lt;a href=&quot;http://mihai.bazon.net/projects/javascript-syntax-highlighting-engine&quot;&gt;DlHightLight代码高亮组件&lt;/a&gt;和&lt;a href=&quot;http://code.google.com/p/google-code-prettify/&quot;&gt;Google Code Prettify&lt;/a&gt;。DLHightLight支持的语言相对较少一些，有js、css、xml和html，Google的高亮插件基本上任何语言都支持，也可以自定义语言，也支持自动识别，也有行号的特别支持。&lt;/p&gt;

&lt;p&gt;Google的高亮插件使用也比较方便，只需要在&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;的标签上加入&lt;code&gt;prettyprint&lt;/code&gt;即可。所以我选择了Google Code Prettify。&lt;/p&gt;

&lt;h2&gt;搭建本地jekyll环境&lt;/h2&gt;

&lt;p&gt;这里主要介绍一下在Mac OS X下面的安装过程，其他操作系统可以参考官方的&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Install&quot;&gt;jekyll安装&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;作为生活在水深火热的墙内人民，有必要进行下面一步修改gem的源，方便我们更快的下载所需组建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gem sources --remove http://rubygems.org/ 
sudo gem sources -a http://ruby.taobao.org/ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用Gem安装jekyll&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过一般如果有出错提示，你可能需要这样安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我到了这一步的时候总是提示错误&lt;code&gt;Failed to build gem native extension&lt;/code&gt;，很可能的一个原因是没有安装rvm，&lt;a href=&quot;https://rvm.io/rvm/install/&quot;&gt;rvm的安装&lt;/a&gt;可以参考这里，或者敲入下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L https://get.rvm.io | bash -s stable --ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后还需要安装Markdown的解释器，这个需要在你的_config.yml里面设置&lt;code&gt;markdown:rdiscount&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll rdiscount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，如果一切顺利的话，本地环境就基本搭建完成了，进入之前我们建立的博客目录，运行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll --server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候，你就可以通过&lt;code&gt;localhost:4000&lt;/code&gt;来访问了。还有关于&lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;jekyll bootstrap&lt;/a&gt;的资料，需要自己修改调试的，可以研究一下。&lt;/p&gt;

&lt;p&gt;我在这个过程中还遇到两个诡异的没有解决的问题，一个是我放在根目录下面的blog.md等文件，在GitHub的pages服务上一切正常，可以通过&lt;code&gt;beiyuu.com/blog&lt;/code&gt;访问的到，但是在本地环境下，总是&lt;code&gt;not found&lt;/code&gt;，很是让人郁闷，看生成的&lt;code&gt;_site&lt;/code&gt;目录下面的文件，也是正常的&lt;code&gt;blog.html&lt;/code&gt;，但就是找不到，只有当我把URL改为&lt;code&gt;localhost:4000/blog.html&lt;/code&gt;的时候，才能访问的到，环境不同真糟糕。&lt;/p&gt;

&lt;p&gt;还有一个是关于&lt;code&gt;category&lt;/code&gt;的问题，根据&lt;code&gt;YAML&lt;/code&gt;的语法，我们在文章头部可以定义文章所属的类别，也可以定义为&lt;code&gt;category:[blog,rss]&lt;/code&gt;这样子的多类别，我在本地试一切正常，但是push到GitHub之后，就无法读取了，真让人着急，没有办法，只能采用别的办法满足我的需求了。这里还有一篇&lt;a href=&quot;http://chxt6896.github.com/blog/2012/02/13/blog-jekyll-native.html&quot;&gt;Jekyll 本地调试之若干问题&lt;/a&gt;，安装中如果有其他问题，也可以对照参考一下。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;如果你跟着这篇不那么详尽的教程，成功搭建了自己的博客，恭喜你！剩下的就是保持热情的去写自己的文章吧。&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
